<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Less extends CSS with dynamic behavior such as variables, mixins, operations and functions. Less runs on both the server-side (with Node.js and Rhino) or client-side (modern browsers only).
">
<meta name="author" content="The Core Less Team">

<title>
  Language Features | Less.js
</title>

<!-- Main styles -->
<link href="../public/css/index.css" rel="stylesheet">

<!-- Webfonts -->
<script type="text/javascript">
  WebFontConfig = {google: {families: ['PT+Sans:400,700,400italic,700italic', 'PT+Mono&subset=latin,cyrillic'] }};
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
  <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
  <script src="//oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
<![endif]-->

<!-- Favicons -->
<link rel="shortcut icon" href="../public/ico/favicon.ico">

  </head>
  <body class="features">
    
    <header class="navbar navbar-inverse navbar-fixed-top docs-nav" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="../#" class="navbar-brand" alt="Less">
        <img src="../public/img/logo.png">
      </a>
    </div>
    <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
      <ul class="nav navbar-nav">
        <li class="active">
          <a href="/">Language Features</a>
        </li>
        
        <li>
          <a href="../functions/">Function Reference</a>
        </li>
        <li>
          <a href="../usage/">Usage</a>
        </li>
        
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
        <li>
          <a href="../about/">About</a>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown">GitHub <b class="caret"></b></a>
          <ul class="dropdown-menu">
            <li> <a href="https://github.com/less/less-docs">Docs Repo</a> </li>
            <li> <a href="https://github.com/less/less-docs/issues?&amp;state=open">Docs Issues</a> </li>
            <li class="divider"></li>
            <li> <a href="https://github.com/less/less.js.git">Less.js Repo</a> </li>
            <li> <a href="https://github.com/less/less.js/issues">Less.js Issues</a> </li>
          </ul>
        </li>
      </ul>
    </nav>
  </div>
</header>


    
<div class="docs-header" id="content">
  <div class="container">
    <h1>Language Features</h1>
    <p>Features of the Less language</p>
    
  </div>
</div>


<div class="banner">
  <div class="container">
    less v1.7.1 has been released -
    <strong>
      <a href="https://github.com/less/less.js/blob/master/CHANGELOG.md">See what's new</a>
    </strong>
  </div>
</div>


    
    <div class="container docs-container">
      <div class="row">
        <div class="col-md-3">
          <div class="sidebar hidden-print" role="complementary">
            <div id="navigation">
  
<ul class="nav sidenav"><li><a href="#features-overview-feature">Overview</a><ul class="nav"><li><a href="#features-overview-feature--variables-">变量(Variables)</a></li>
<li><a href="#features-overview-feature--mixins-">混合(Mixins)</a></li>
<li><a href="#features-overview-feature--nested-rules-">嵌套规则(Nested rules)</a></li>
<li><a href="#features-overview-feature-media-query-bubbling-and-nested-media-queries">Media query bubbling and nested media queries</a></li>
<li><a href="#features-overview-feature--operations-">运算(Operations)</a></li>
<li><a href="#features-overview-feature--functions-">函数(Functions)</a></li>
<li><a href="#features-overview-feature--namespaces-accessors-">命名空间和访问器(Namespaces & Accessors)</a></li>
<li><a href="#features-overview-feature--scope-">作用域(Scope)</a></li>
<li><a href="#features-overview-feature--comments-">注释(Comments)</a></li>
<li><a href="#features-overview-feature--importing-">导入(Importing)</a></li></ul></li>
<li><a href="#variables-feature">Variables</a><ul class="nav"><li><a href="#variables-feature--overview-">概述(Overview)</a></li>
<li><a href="#variables-feature--variable-interpolation-">变量插值(Variable Interpolation)</a></li>
<li><a href="#variables-feature--selectors-">选择器(Selectors)</a></li>
<li><a href="#variables-feature-urls">URLs</a></li>
<li><a href="#variables-feature-import-">Import语句</a></li>
<li><a href="#variables-feature--">属性</a></li>
<li><a href="#variables-feature--">变量名</a></li>
<li><a href="#variables-feature--">延迟加载</a></li>
<li><a href="#variables-feature--">默认变量</a></li></ul></li>
<li><a href="#extend-feature">Extend</a><ul class="nav"><li><a href="#extend-feature--extend-">扩展语法(extend语法)</a></li>
<li><a href="#extend-feature--">为选择器附加扩展</a></li>
<li><a href="#extend-feature--extend">规则集内的extend</a></li>
<li><a href="#extend-feature--extend">嵌套选择器中的extend</a></li>
<li><a href="#extend-feature-extend-">extend中的精确匹配</a></li>
<li><a href="#extend-feature-nth-">nth表达式</a></li>
<li><a href="#extend-feature-extend-all-">Extend "all"</a></li>
<li><a href="#extend-feature-extend-">Extend中的选择器插值</a></li>
<li><a href="#extend-feature--media-extend">作用域/@media内的extend</a></li>
<li><a href="#extend-feature--">检测重复</a></li>
<li><a href="#extend-feature-extend-">Extend用例</a></li>
<li><a href="#extend-feature--">经典用例</a></li>
<li><a href="#extend-feature-css-">CSS尺寸归并</a></li>
<li><a href="#extend-feature--mixin">合并样式/更高级的mixin</a></li></ul></li>
<li><a href="#mixins-feature">Mixins</a><ul class="nav"><li><a href="#mixins-feature--">不输出混合集</a></li>
<li><a href="#mixins-feature--">带选择器的混合集</a></li>
<li><a href="#mixins-feature--">命名空间</a></li>
<li><a href="#mixins-feature--important-">!important 关键字</a></li></ul></li>
<li><a href="#mixins-parametric-feature">Parametric Mixins</a><ul class="nav"><li><a href="#mixins-parametric-feature--mixins">带多个参数的mixins</a></li>
<li><a href="#mixins-parametric-feature--">命名参数</a></li>
<li><a href="#mixins-parametric-feature--arguments-">@arguments 变量</a></li>
<li><a href="#mixins-parametric-feature--rest-">高级参数和@rest变量</a></li>
<li><a href="#mixins-parametric-feature--">模式匹配</a></li></ul></li>
<li><a href="#mixins-as-functions-feature">Mixins as Functions</a></li>
<li><a href="#detached-rulesets-feature">Passing Rulesets to Mixins</a></li>
<li><a href="#import-directives-feature">Import Directives</a><ul class="nav"><li><a href="#import-directives-feature--">文件扩展名</a></li></ul></li>
<li><a href="#-">导入选项</a><ul class="nav"><li><a href="#--reference">reference</a></li>
<li><a href="#--reference-">reference示例</a></li>
<li><a href="#--inline">inline</a></li>
<li><a href="#--less">less</a></li>
<li><a href="#--css">css</a></li>
<li><a href="#--once">once</a></li>
<li><a href="#--multiple">multiple</a></li></ul></li>
<li><a href="#mixin-guards-feature">Mixin Guards</a><ul class="nav"><li><a href="#mixin-guards-feature-guard-">Guard中的比较运算符</a></li>
<li><a href="#mixin-guards-feature-guard-logical-operators">Guard logical operators</a></li>
<li><a href="#mixin-guards-feature--">类型检查函数</a></li>
<li><a href="#mixin-guards-feature--mixins">带条件的mixins</a></li></ul></li>
<li><a href="#css-guards-feature">CSS Guards</a></li>
<li><a href="#loops-feature">Loops</a></li>
<li><a href="#merge-feature">Merge</a><ul class="nav"><li><a href="#merge-feature--">逗号</a></li>
<li><a href="#merge-feature-space">Space</a></li></ul></li>
<li><a href="#parent-selectors-feature">Parent Selectors</a><ul class="nav"><li><a href="#parent-selectors-feature--">多个 &</a></li>
<li><a href="#parent-selectors-feature--">改变选择器顺序</a></li>
<li><a href="#parent-selectors-feature--explosion-">组合使用(explosion->爆发?)</a></li></ul></li></ul></div>
          </div>
        </div>
        <div class="col-md-9" role="main">
          
<div class="panel docs-content">
  


  <!-- Overview -->
  <div class="docs-section">
    <div class="page-header">
      <h1 class="docs-heading">Overview<span class="anchor-target" id="features-overview-feature"></span>
<a href="#features-overview-feature" name="features-overview-feature" class="anchor glyphicon glyphicon-link"></a></h1>
    </div>

    
    <div class="section-content">
      
<a class="glyphicon glyphicon-pencil source-link right" href="/blob//content_zh/features-overview.md" data-content="features-overviewmd" target="_blank"></a>



<a id="features-overviewmd" href="/blob//content_zh/features-overview.md" target="_blank">Edit the markdown source for "features-overview"
  <span class="glyphicon glyphicon-new-window"></span>
</a>

      <!-- features-overview -->
       


<blockquote>
<p>作为一种 CSS 扩展, Less 不仅向后兼容 CSS, 它还使用现有的 CSS 语法新增了额外的特性. 这使得学习 Less 更轻松, 一旦有任何问题，可以随时退回使用标准的 CSS.</p>
</blockquote>
<h3 class="docs-heading">变量(Variables)<span class="anchor-target" id="features-overview-feature--variables-"></span>
<a href="#features-overview-feature--variables-" name="features-overview-feature--variables-" class="anchor glyphicon glyphicon-link"></a></h3>
<p>顾名思义:</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@nice-blue: <span class="hljs-hexcolor">#5B83AD</span>;</span>
<span class="hljs-at_rule">@light-blue: @nice-blue + <span class="hljs-hexcolor">#111</span>;</span>

<span class="hljs-id">#header</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: @light-blue;</span>
}
</code></pre>
<p>输出:</p>
<pre><code class="lang-css"><span class="hljs-id">#header</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#6c94be</span></span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>注意，由于变量只能定义一次，实际上他们就是“常量”.</p>
<h3 class="docs-heading">混合(Mixins)<span class="anchor-target" id="features-overview-feature--mixins-"></span>
<a href="#features-overview-feature--mixins-" name="features-overview-feature--mixins-" class="anchor glyphicon glyphicon-link"></a></h3>
<p>混合就是一种将一系列属性从一个规则集引入(“混合”)到另一个规则集的方式。假设我们有以下 <code>class</code>:</p>
<pre><code class="lang-css"><span class="hljs-class">.bordered</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">border-top</span>:<span class="hljs-value"> dotted <span class="hljs-number">1</span>px black</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">border-bottom</span>:<span class="hljs-value"> solid <span class="hljs-number">2</span>px black</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>我们希望在另一个规则集内部使用上面这些属性。那么，我们就只需要访问我们想要的属性所在类的名称即可，就像下面这样：</p>
<pre><code class="lang-less"><span class="hljs-id">#menu</span> <span class="hljs-tag">a</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: <span class="hljs-hexcolor">#111</span>;</span>
  <span class="hljs-class">.bordered</span>;
}

<span class="hljs-class">.post</span> <span class="hljs-tag">a</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: red;</span>
  <span class="hljs-class">.bordered</span>;
}
</code></pre>
<p>类 <code>.bordered</code> 的属性现在就会同事呈现在 <code>#menu a</code> 和 <code>.post a</code> 中了（注意，同样可以将 <code>#ids</code> 作为 mixins）。</p>
<p><strong>Learn more</strong></p>
<ul>
<li><a href="#mixins-feature">More about mixins</a></li>
<li><a href="#mixins-parametric-feature">Parametric Mixins</a></li>
</ul>
<h3 class="docs-heading">嵌套规则(Nested rules)<span class="anchor-target" id="features-overview-feature--nested-rules-"></span>
<a href="#features-overview-feature--nested-rules-" name="features-overview-feature--nested-rules-" class="anchor glyphicon glyphicon-link"></a></h3>
<p>Less 为我们提供了嵌套的能力, 而不是合并在样式表中.假设我们有下面的 CSS:</p>
<pre><code class="lang-css"><span class="hljs-id">#header</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> black</span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-id">#header</span> <span class="hljs-class">.navigation</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">font-size</span>:<span class="hljs-value"> <span class="hljs-number">12</span>px</span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-id">#header</span> <span class="hljs-class">.logo</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">300</span>px</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>在 Less 中，我们可以以下面这种方式编写:</p>
<pre><code class="lang-less"><span class="hljs-id">#header</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: black;</span>
  <span class="hljs-class">.navigation</span> {
    <span class="hljs-attribute">font-size</span><span class="hljs-value">: <span class="hljs-number">12</span>px;</span>
  }
  <span class="hljs-class">.logo</span> {
    <span class="hljs-attribute">width</span><span class="hljs-value">: <span class="hljs-number">300</span>px;</span>
  }
}
</code></pre>
<p>这样的代码更简洁, 它模仿了 HTML 的结构.</p>
<p>使用这种方法照样可以在混合中包含伪类(pseudo-selectors)。下面是一个经典的 clearfix 代码，在这里使用 mixin 重写了（<code>&amp;</code> 表示当前选择器的父选择器）:</p>
<pre><code class="lang-less"><span class="hljs-class">.clearfix</span> {
  <span class="hljs-attribute">display</span><span class="hljs-value">: block;</span>
  zoom<span class="hljs-value">: <span class="hljs-number">1</span>;</span>

  &amp;<span class="hljs-pseudo">:after</span> {
    <span class="hljs-attribute">content</span><span class="hljs-value">: <span class="hljs-string">" "</span>;</span>
    <span class="hljs-attribute">display</span><span class="hljs-value">: block;</span>
    <span class="hljs-attribute">font-size</span><span class="hljs-value">: <span class="hljs-number">0</span>;</span>
    <span class="hljs-attribute">height</span><span class="hljs-value">: <span class="hljs-number">0</span>;</span>
    <span class="hljs-attribute">clear</span><span class="hljs-value">: both;</span>
    <span class="hljs-attribute">visibility</span><span class="hljs-value">: hidden;</span>
  }
}
</code></pre>
<p><strong>See also</strong></p>
<ul>
<li><a href="#parent-selectors-feature">Parent Selectors</a></li>
</ul>
<h3 class="docs-heading">Media query bubbling and nested media queries<span class="anchor-target" id="features-overview-feature-media-query-bubbling-and-nested-media-queries"></span>
<a href="#features-overview-feature-media-query-bubbling-and-nested-media-queries" name="features-overview-feature-media-query-bubbling-and-nested-media-queries" class="anchor glyphicon glyphicon-link"></a></h3>
<p>Media queries can be nested in the same way as selectors. Selector are copied into the body of the media query:</p>
<pre><code class="lang-less"><span class="hljs-class">.screencolor</span>{
  <span class="hljs-at_rule">@<span class="hljs-keyword">media</span><span class="hljs-preprocessor"> screen</span> {</span>
    <span class="hljs-attribute">color</span><span class="hljs-value">: green;</span>
    <span class="hljs-at_rule">@<span class="hljs-keyword">media</span> (min-width:<span class="hljs-number">768</span>px) {</span>
    <span class="hljs-attribute">color</span><span class="hljs-value">: red;</span>
    }
    }
  <span class="hljs-at_rule">@<span class="hljs-keyword">media</span><span class="hljs-preprocessor"> tv</span> {</span>
    <span class="hljs-attribute">color</span><span class="hljs-value">: black;</span>
  }
}
</code></pre>
<p>outputs:</p>
<pre><code class="lang-css"><span class="hljs-at_rule">@<span class="hljs-keyword">media</span> screen </span>{
  <span class="hljs-class">.screencolor</span> <span class="hljs-rules">{
    <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> green</span></span>;
  <span class="hljs-rule">}</span></span>
}
<span class="hljs-at_rule">@<span class="hljs-keyword">media</span> screen and (min-width: <span class="hljs-number">768</span>px) </span>{
  <span class="hljs-class">.screencolor</span> <span class="hljs-rules">{
    <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> red</span></span>;
  <span class="hljs-rule">}</span></span>
}
<span class="hljs-at_rule">@<span class="hljs-keyword">media</span> tv </span>{
  <span class="hljs-class">.screencolor</span> <span class="hljs-rules">{
    <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> black</span></span>;
  <span class="hljs-rule">}</span></span>
}
</code></pre>
<h3 class="docs-heading">运算(Operations)<span class="anchor-target" id="features-overview-feature--operations-"></span>
<a href="#features-overview-feature--operations-" name="features-overview-feature--operations-" class="anchor glyphicon glyphicon-link"></a></h3>
<p>任何数值，颜色和变量都可以进行运算。这里有一对示例：</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@base:<span class="hljs-preprocessor"> 5</span>%;</span>
<span class="hljs-at_rule">@filler: @base *<span class="hljs-preprocessor"> 2</span>;</span>
<span class="hljs-at_rule">@other: @base + @filler;</span>

<span class="hljs-attribute">color</span><span class="hljs-value">: <span class="hljs-hexcolor">#888</span> / <span class="hljs-number">4</span>;</span>
<span class="hljs-attribute">background-color</span><span class="hljs-value">: @base-color + <span class="hljs-hexcolor">#111</span>;</span>
<span class="hljs-attribute">height</span><span class="hljs-value">: <span class="hljs-number">100</span>% / <span class="hljs-number">2</span> + @filler;</span>
</code></pre>
<p>最后的输出结果与你预期的一样 -- Less 能够推断颜色和单位之间的区别。如果在一个运算中使用了单位，比如：</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@var:<span class="hljs-preprocessor"> 1px</span> +<span class="hljs-preprocessor"> 5</span>;</span>
</code></pre>
<p>在这个例子中 Less 会在最终输出结果中使用这个单位 -- <code>6px</code>。</p>
<h3 class="docs-heading">函数(Functions)<span class="anchor-target" id="features-overview-feature--functions-"></span>
<a href="#features-overview-feature--functions-" name="features-overview-feature--functions-" class="anchor glyphicon glyphicon-link"></a></h3>
<p>Less 提供了许多用于转换颜色，处理字符串和进行算术运算的函数。他们在函数参考一节有详细的的介绍。</p>
<p>这些函数使用起来非常简单。在下面的例子中我们使用 <code>percentage</code> 将 0.5 转换为 50%，然后将基础颜色值的饱和度增加了 5%，最后将背景颜色的亮度增加了 25% 之后又将色相值增加 8:</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@base: <span class="hljs-hexcolor">#f04615</span>;</span>
<span class="hljs-at_rule">@width:<span class="hljs-preprocessor"> 0.5</span>;</span>

<span class="hljs-class">.class</span> {
  <span class="hljs-attribute">width</span><span class="hljs-value">: percentage(@width);</span> <span class="hljs-comment">// returns `50%`</span>
  <span class="hljs-attribute">color</span><span class="hljs-value">: saturate(@base, <span class="hljs-number">5</span>%);</span>
  <span class="hljs-attribute">background-color</span><span class="hljs-value">: spin(lighten(@base, <span class="hljs-number">25</span>%), <span class="hljs-number">8</span>);</span>
}
</code></pre>
<h3 class="docs-heading">命名空间和访问器(Namespaces &amp; Accessors)<span class="anchor-target" id="features-overview-feature--namespaces-accessors-"></span>
<a href="#features-overview-feature--namespaces-accessors-" name="features-overview-feature--namespaces-accessors-" class="anchor glyphicon glyphicon-link"></a></h3>
<p>(不要将它与 <a href="http://www.w3.org/TR/css3-namespace/">CSS <code>@namespace</code></a> or <a href="http://www.w3.org/TR/css3-selectors/#typenmsp">namespace 选择器</a>混为一谈)。</p>
<p>有时候，出于组织的目的，或者为了提供一些封装，你会希望将你的mixins 组合在一起。在 Less 中做到这一点非常直观，假设你想在 <code>#bundle</code> 下捆绑一些 mixins 和变量，以便稍候复用或者分发：</p>
<pre><code class="lang-less"><span class="hljs-id">#bundle</span> {
  <span class="hljs-class">.button</span> {
    <span class="hljs-attribute">display</span><span class="hljs-value">: block;</span>
    <span class="hljs-attribute">border</span><span class="hljs-value">: <span class="hljs-number">1</span>px solid black;</span>
    <span class="hljs-attribute">background-color</span><span class="hljs-value">: grey;</span>
    &amp;<span class="hljs-pseudo">:hover</span> {
      <span class="hljs-attribute">background-color</span><span class="hljs-value">: white
    }
  }
  .tab { ... }
  .citation { ... }
}</span>
</code></pre>
<p>现在如果我们想在 <code>#header a</code> 中混合 <code>.button</code> 类，那么我们可以这样做：</p>
<pre><code class="lang-less"><span class="hljs-id">#header</span> <span class="hljs-tag">a</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: orange;</span>
  <span class="hljs-id">#bundle</span> &gt; <span class="hljs-class">.button</span>;
}
</code></pre>
<p>Note that variables declared within a namespace will be scoped to that namespace only and will not be available outside of the scope via the same syntax that you would use to reference a mixin (<code>#Namespace &gt; .mixin-name</code>). So, for example, you can&#39;t do the following: (<code>#Namespace &gt; @this-will-not-work</code>).</p>
<h3 class="docs-heading">作用域(Scope)<span class="anchor-target" id="features-overview-feature--scope-"></span>
<a href="#features-overview-feature--scope-" name="features-overview-feature--scope-" class="anchor glyphicon glyphicon-link"></a></h3>
<p>Less 中的作用域与编程语言中的作用域概念非常相似。首先会在局部查找变量和混合，如果没找到，编译器就会在父作用域中查找，依次类推。</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@var:<span class="hljs-preprocessor"> red</span>;</span>

<span class="hljs-id">#page</span> {
  <span class="hljs-at_rule">@var:<span class="hljs-preprocessor"> white</span>;</span>
  <span class="hljs-id">#header</span> {
    <span class="hljs-attribute">color</span><span class="hljs-value">: @var;</span> <span class="hljs-comment">// white</span>
  }
}
</code></pre>
<p>变量和混合不必在使用前声明，因此下面的代码与前面的例子等价：</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@var:<span class="hljs-preprocessor"> red</span>;</span>

<span class="hljs-id">#page</span> {
  <span class="hljs-id">#header</span> {
    <span class="hljs-attribute">color</span><span class="hljs-value">: @var;</span> <span class="hljs-comment">// white</span>
  }
  <span class="hljs-at_rule">@var:<span class="hljs-preprocessor"> white</span>;</span>
}
</code></pre>
<p><strong>See also</strong></p>
<ul>
<li><a href="#variables-feature-lazy-loading">Lazy Loading</a></li>
</ul>
<h3 class="docs-heading">注释(Comments)<span class="anchor-target" id="features-overview-feature--comments-"></span>
<a href="#features-overview-feature--comments-" name="features-overview-feature--comments-" class="anchor glyphicon glyphicon-link"></a></h3>
<p>可以使用块注释和行注释:</p>
<pre><code class="lang-less"><span class="hljs-comment">/* One hell of a block
style comment! */</span>
<span class="hljs-at_rule">@var:<span class="hljs-preprocessor"> red</span>;</span>

<span class="hljs-comment">// Get in line!</span>
<span class="hljs-at_rule">@var:<span class="hljs-preprocessor"> white</span>;</span>
</code></pre>
<h3 class="docs-heading">导入(Importing)<span class="anchor-target" id="features-overview-feature--importing-"></span>
<a href="#features-overview-feature--importing-" name="features-overview-feature--importing-" class="anchor glyphicon glyphicon-link"></a></h3>
<p>导入工作与你预期的一样。你可以导入一个 <code>.less</code> 文件，然后这个文件中的所有变量都可以使用了。对于 <code>.less</code> 文件而言，其扩展名是可选的。</p>
<pre><code class="lang-css">@import &quot;library&quot;; // library.less
@import &quot;typo.css&quot;;
</code></pre>


      <br>
    </div>
    

  </div>

  <!-- Variables -->
  <div class="docs-section">
    <div class="page-header">
      <h1 class="docs-heading">Variables<span class="anchor-target" id="variables-feature"></span>
<a href="#variables-feature" name="variables-feature" class="anchor glyphicon glyphicon-link"></a></h1>
    </div>

    
    <div class="section-content">
      
<a class="glyphicon glyphicon-pencil source-link right" href="/blob//content_zh/features/variables.md" data-content="variablesmd" target="_blank"></a>



<a id="variablesmd" href="/blob//content_zh/features/variables.md" target="_blank">Edit the markdown source for "variables"
  <span class="glyphicon glyphicon-new-window"></span>
</a>

      <!-- variables -->
       


<blockquote>
<p>在一个地方管理常用的值。</p>
</blockquote>
<h2 class="docs-heading">概述(Overview)<span class="anchor-target" id="variables-feature--overview-"></span>
<a href="#variables-feature--overview-" name="variables-feature--overview-" class="anchor glyphicon glyphicon-link"></a></h2>
<p>在你的样式表中相同的值重复几十次<em>甚至上百次</em>并不少见：</p>
<pre><code class="lang-css"><span class="hljs-tag">a</span>,
<span class="hljs-class">.link</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#428bca</span></span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-class">.widget</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#fff</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">background</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#428bca</span></span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>变量通过为你提供一种在一个地方管理这些值的方法让你的代码变得更容易维护：</p>
<pre><code class="lang-less"><span class="hljs-comment">// 变量</span>
<span class="hljs-at_rule">@link-color:        <span class="hljs-hexcolor">#428bca</span>;</span> <span class="hljs-comment">// sea blue</span>
<span class="hljs-at_rule">@link-color-hover: <span class="hljs-preprocessor"> darken</span>(@link-color,<span class="hljs-preprocessor"> 10</span>%);</span>

<span class="hljs-comment">// 用法</span>
<span class="hljs-tag">a</span>,
<span class="hljs-class">.link</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: @link-color;</span>
}
<span class="hljs-tag">a</span><span class="hljs-pseudo">:hover</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: @link-color-hover;</span>
}
<span class="hljs-class">.widget</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: <span class="hljs-hexcolor">#fff</span>;</span>
  <span class="hljs-attribute">background</span><span class="hljs-value">: @link-color;</span>
}
</code></pre>
<h2 class="docs-heading">变量插值(Variable Interpolation)<span class="anchor-target" id="variables-feature--variable-interpolation-"></span>
<a href="#variables-feature--variable-interpolation-" name="variables-feature--variable-interpolation-" class="anchor glyphicon glyphicon-link"></a></h2>
<p>在上面的例子主要集中于<em>在CSS规则中使用变量管理值</em>，实际上它们还可以用在其他地方，比如选择器名称，属性名，URLs以及<code>@import</code>语句中。</p>
<h3 class="docs-heading">选择器(Selectors)<span class="anchor-target" id="variables-feature--selectors-"></span>
<a href="#variables-feature--selectors-" name="variables-feature--selectors-" class="anchor glyphicon glyphicon-link"></a></h3>
<p>版本: 1.4.0</p>
<pre><code class="lang-less"><span class="hljs-comment">// 变量</span>
<span class="hljs-at_rule">@mySelector:<span class="hljs-preprocessor"> banner</span>;</span>

<span class="hljs-comment">// 用法</span>
.<span class="hljs-at_rule">@{</span>mySelector} {
  <span class="hljs-attribute">font-weight</span><span class="hljs-value">: bold;</span>
  <span class="hljs-attribute">line-height</span><span class="hljs-value">: <span class="hljs-number">40</span>px;</span>
  <span class="hljs-attribute">margin</span><span class="hljs-value">: <span class="hljs-number">0</span> auto;</span>
}
</code></pre>
<p>最终编译为：</p>
<pre><code class="lang-css"><span class="hljs-class">.banner</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">font-weight</span>:<span class="hljs-value"> bold</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">line-height</span>:<span class="hljs-value"> <span class="hljs-number">40</span>px</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">margin</span>:<span class="hljs-value"> <span class="hljs-number">0</span> auto</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<h3 class="docs-heading">URLs<span class="anchor-target" id="variables-feature-urls"></span>
<a href="#variables-feature-urls" name="variables-feature-urls" class="anchor glyphicon glyphicon-link"></a></h3>
<pre><code class="lang-less"><span class="hljs-comment">// 变量</span>
<span class="hljs-at_rule">@images: <span class="hljs-string">"../img"</span>;</span>

<span class="hljs-comment">// 用法</span>
<span class="hljs-tag">body</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: <span class="hljs-hexcolor">#444</span>;</span>
  <span class="hljs-attribute">background</span><span class="hljs-value">: url(<span class="hljs-string">"@{images}/white-sand.png"</span>);</span>
}
</code></pre>
<h3 class="docs-heading">Import语句<span class="anchor-target" id="variables-feature-import-"></span>
<a href="#variables-feature-import-" name="variables-feature-import-" class="anchor glyphicon glyphicon-link"></a></h3>
<p>版本: 1.4.0</p>
<p>语法: <code>@import &quot;@{themes}/tidal-wave.less&quot;;</code></p>
<p>注意，目前都只有将变量声明在根作用域或者是当前作用域中，然后只有当前文件以及使用这个文件时才会考虑什么时候查找一个变量。这意味着这种用法通常在你注入变量到编译过程中或者在根文件的开始部分声明变量的做法是有限的。</p>
<p>当你引入一个CSS文件，同时不使用内联选项（比如，import语句保持不变）时让面的规则就不会应用。</p>
<p>示例：</p>
<pre><code class="lang-less"><span class="hljs-comment">// 变量</span>
<span class="hljs-at_rule">@themes: <span class="hljs-string">"../../src/themes"</span>;</span>

<span class="hljs-comment">// 用法</span>
<span class="hljs-at_rule">@<span class="hljs-keyword">import</span> <span class="hljs-string">"@{themes}/tidal-wave.less"</span>;</span>
</code></pre>
<h3 class="docs-heading">属性<span class="anchor-target" id="variables-feature--"></span>
<a href="#variables-feature--" name="variables-feature--" class="anchor glyphicon glyphicon-link"></a></h3>
<p>版本: 1.6.0</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@property:<span class="hljs-preprocessor"> color</span>;</span>

<span class="hljs-class">.widget</span> {
  <span class="hljs-at_rule">@{</span>property}<span class="hljs-value">: <span class="hljs-hexcolor">#0ee</span>;</span>
  <span class="hljs-attribute">background</span>-<span class="hljs-at_rule">@{</span>property}<span class="hljs-value">: <span class="hljs-hexcolor">#999</span>;</span>
}
</code></pre>
<p>编译为：</p>
<pre><code class="lang-css"><span class="hljs-class">.widget</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#0ee</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">background-color</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#999</span></span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<h2 class="docs-heading">变量名<span class="anchor-target" id="variables-feature--"></span>
<a href="#variables-feature--" name="variables-feature--" class="anchor glyphicon glyphicon-link"></a></h2>
<p>还可以使用变量来定义变量名：</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@fnord:  <span class="hljs-string">"I am fnord."</span>;</span>
<span class="hljs-at_rule">@var:    <span class="hljs-string">"fnord"</span>;</span>
<span class="hljs-attribute">content</span><span class="hljs-value">: @@var;</span>
</code></pre>
<p>这会编译为：</p>
<pre><code>content: &quot;I am fnord.&quot;;
</code></pre><h2 class="docs-heading">延迟加载<span class="anchor-target" id="variables-feature--"></span>
<a href="#variables-feature--" name="variables-feature--" class="anchor glyphicon glyphicon-link"></a></h2>
<blockquote>
<p>变量是延迟加载的，在使用前不一定要预先声明。</p>
</blockquote>
<p>有效的Less片段：</p>
<pre><code class="lang-less"><span class="hljs-class">.lazy-eval</span> {
  <span class="hljs-attribute">width</span><span class="hljs-value">: @var;</span>
}

<span class="hljs-at_rule">@var: @a;</span>
<span class="hljs-at_rule">@a:<span class="hljs-preprocessor"> 9</span>%;</span>
</code></pre>
<p>下面这个也是有效的Less片段：</p>
<pre><code class="lang-less"><span class="hljs-class">.lazy-eval-scope</span> {
  <span class="hljs-attribute">width</span><span class="hljs-value">: @var;</span>
  <span class="hljs-at_rule">@a:<span class="hljs-preprocessor"> 9</span>%;</span>
}

<span class="hljs-at_rule">@var: @a;</span>
<span class="hljs-at_rule">@a:<span class="hljs-preprocessor"> 100</span>%;</span>
</code></pre>
<p>最终都会编译为：</p>
<pre><code class="lang-css"><span class="hljs-class">.lazy-eval-scope</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">9</span>%</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>在定义一个变量两次时，只会使用最后定义的变量，Less会从当前作用域中向上搜索。这个行为类似于CSS的定义中始终使用最后定义的属性值。</p>
<p>比如：</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@var:<span class="hljs-preprocessor"> 0</span>;</span>
<span class="hljs-class">.class</span> {
  <span class="hljs-at_rule">@var:<span class="hljs-preprocessor"> 1</span>;</span>
  <span class="hljs-class">.brass</span> {
    <span class="hljs-at_rule">@var:<span class="hljs-preprocessor"> 2</span>;</span>
    three<span class="hljs-value">: @var;</span>
    <span class="hljs-at_rule">@var:<span class="hljs-preprocessor"> 3</span>;</span>
  }
  one<span class="hljs-value">: @var;</span>
}
</code></pre>
<p>会编译为：</p>
<pre><code class="lang-css"><span class="hljs-class">.class</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">one</span>:<span class="hljs-value"> <span class="hljs-number">1</span></span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-class">.class</span> <span class="hljs-class">.brass</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">three</span>:<span class="hljs-value"> <span class="hljs-number">3</span></span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<h2 class="docs-heading">默认变量<span class="anchor-target" id="variables-feature--"></span>
<a href="#variables-feature--" name="variables-feature--" class="anchor glyphicon glyphicon-link"></a></h2>
<p>有时候你会用到默认变量-让你能够在没有设置某些变量的情况下设置指定的变量。这一特性并不强制要求你这么做，因为你可以很容易通过插入后定义同名变量的方式覆盖默认变量。</p>
<p>比如：</p>
<pre><code class="lang-less"><span class="hljs-comment">// library</span>
<span class="hljs-at_rule">@base-color:<span class="hljs-preprocessor"> green</span>;</span>
<span class="hljs-at_rule">@dark-color:<span class="hljs-preprocessor"> darken</span>(@base-color,<span class="hljs-preprocessor"> 10</span>%);</span>

<span class="hljs-comment">// use of library</span>
<span class="hljs-at_rule">@<span class="hljs-keyword">import</span> <span class="hljs-string">"library.less"</span>;</span>
<span class="hljs-at_rule">@base-color:<span class="hljs-preprocessor"> red</span>;</span>
</code></pre>
<p>这个是能够工作的 - 其中base-color会被重写，而dark-color依然是暗红色。</p>


      <br>
    </div>
    

  </div>

  <!-- Extend -->
  <div class="docs-section">
    <div class="page-header">
      <h1 class="docs-heading">Extend<span class="anchor-target" id="extend-feature"></span>
<a href="#extend-feature" name="extend-feature" class="anchor glyphicon glyphicon-link"></a></h1>
    </div>

    
    <div class="section-content">
      
<a class="glyphicon glyphicon-pencil source-link right" href="/blob//content_zh/features/extend.md" data-content="extendmd" target="_blank"></a>



<a id="extendmd" href="/blob//content_zh/features/extend.md" target="_blank">Edit the markdown source for "extend"
  <span class="glyphicon glyphicon-new-window"></span>
</a>

      <!-- extend -->
       


<blockquote>
<p>extend是一个Less伪类，它会合并它所在的选择其和它所匹配的引用。</p>
</blockquote>
<p>发布于 <a href="https://github.com/less/less.js/blob/masterCHANGELOG.md">v1.4.0</a></p>
<pre><code class="lang-less"><span class="hljs-tag">nav</span> <span class="hljs-tag">ul</span> {
  &amp;<span class="hljs-value">:extend(.inline);</span>
  <span class="hljs-attribute">background</span><span class="hljs-value">: blue;</span>
}
</code></pre>
<p>在上面设置的规则中，<code>:extend</code>选择器会在<em><code>.inline</code>类出现的地方</em>在<code>.inline</code>上应用&quot;扩展选择器&quot;(也就是<code>nav ul</code>)。声明块保持原样，不会带有任何引用扩展(因为扩展并不是CSS)。</p>
<p>因此下面的代码：</p>
<pre><code class="lang-less"><span class="hljs-tag">nav</span> <span class="hljs-tag">ul</span> {
  &amp;<span class="hljs-value">:extend(.inline);</span>
  <span class="hljs-attribute">background</span><span class="hljs-value">: blue;</span>
}
<span class="hljs-class">.inline</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: red;</span>
}
</code></pre>
<p>输出：</p>
<pre><code class="lang-css"><span class="hljs-tag">nav</span> <span class="hljs-tag">ul</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">background</span>:<span class="hljs-value"> blue</span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-class">.inline</span>,
<span class="hljs-tag">nav</span> <span class="hljs-tag">ul</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> red</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>注意<code>nav ul:extend(.inline)</code>选择器是如何输出得到<code>nav ul</code>的 - 输出之前移除了扩展，然后选择器块保持不变。如果代码块中没有放入属性，则从输入中移除它（但是扩展仍然会影响其他选择器）。</p>
<h2 class="docs-heading">扩展语法(extend语法)<span class="anchor-target" id="extend-feature--extend-"></span>
<a href="#extend-feature--extend-" name="extend-feature--extend-" class="anchor glyphicon glyphicon-link"></a></h2>
<p>extend可以附加给一个选择器，也可以放入一个规则集中。它看起来像是一个带选择器参数伪类，也可以使用关键字<code>all</code>选择相邻的选择器。</p>
<p>示例：</p>
<pre><code class="lang-less"><span class="hljs-class">.a</span><span class="hljs-value">:extend(.b) {}

// 上面的代码块与下面这个做一样的事情
.a {
  &amp;:extend(.b);</span>
}
</code></pre>
<pre><code class="lang-less"><span class="hljs-class">.c</span><span class="hljs-value">:extend(.d all) {
  // 扩展<span class="hljs-string">".d"</span>的所有实例，比如<span class="hljs-string">".x.d"</span>或者<span class="hljs-string">".d.x"</span>
}
.c:extend(.d) {
  // 扩展选择器输出为<span class="hljs-string">".d"</span>的唯一实例
}</span>
</code></pre>
<p>它可以包含多个要扩展的类，使用逗号分割即可。</p>
<p>示例：</p>
<pre><code class="lang-less"><span class="hljs-class">.e</span><span class="hljs-value">:extend(.f) {}
.e:extend(.g) {}

// 上面的代码与下面的做一样的事情
.e:extend(.f, .g) {}</span>
</code></pre>
<h3 class="docs-heading">为选择器附加扩展<span class="anchor-target" id="extend-feature--"></span>
<a href="#extend-feature--" name="extend-feature--" class="anchor glyphicon glyphicon-link"></a></h3>
<p>给选择器附加扩展看起来就像一个普通的带参数的伪类选择器。一个选择器可以包含多个扩展分支，但是所有的扩展都必须在选择器的尾部。</p>
<ul>
<li>选择器之后的扩展：<code>pre:hover:extend(div pre)</code>。</li>
<li>在选择器和扩展之间有空格是允许的：<code>pre:hover :extend(div pre)</code>.</li>
<li>也允许有多个扩展: <code>pre:hover:extend(div pre):extend(.bucket tr)</code> - 注意这与 <code>pre:hover:extend(div pre, .bucket tr)</code>一样。</li>
<li>这是不允许的: <code>pre:hover:extend(div pre).nth-child(odd)</code>。因为扩展必须在最后。</li>
</ul>
<p>如果一个规则集包含多个选择器，所有选择器都可以使用extend关键字。下面演示了一个规则集中多个带extend的选择器：</p>
<pre><code class="lang-less"><span class="hljs-class">.big-division</span>,
<span class="hljs-class">.big-bag</span><span class="hljs-value">:extend(.bag),
.big-bucket:extend(.bucket) {
  // body
}</span>
</code></pre>
<h3 class="docs-heading">规则集内的extend<span class="anchor-target" id="extend-feature--extend"></span>
<a href="#extend-feature--extend" name="extend-feature--extend" class="anchor glyphicon glyphicon-link"></a></h3>
<p>也可以使用<code>&amp;:extend(selector)</code>语法在规则集内置入extend。将extend放入规则集内是一种将它放入单个规则选择器的快捷方式。</p>
<p>规则内的extend：</p>
<pre><code class="lang-less"><span class="hljs-tag">pre</span><span class="hljs-pseudo">:hover</span>,
<span class="hljs-class">.some-class</span> {
  &amp;<span class="hljs-value">:extend(div pre);</span>
}
</code></pre>
<p>与给每个选择器添加一个extend完全相同：</p>
<pre><code class="lang-less"><span class="hljs-tag">pre</span><span class="hljs-pseudo">:hover</span><span class="hljs-value">:extend(div pre),
.some-class:extend(div pre) {}</span>
</code></pre>
<h3 class="docs-heading">嵌套选择器中的extend<span class="anchor-target" id="extend-feature--extend"></span>
<a href="#extend-feature--extend" name="extend-feature--extend" class="anchor glyphicon glyphicon-link"></a></h3>
<p>extend还可以匹配嵌套选择器，比如有下面的Less：</p>
<p>示例：</p>
<pre><code class="lang-less"><span class="hljs-class">.bucket</span> {
  <span class="hljs-tag">tr</span> { <span class="hljs-comment">// 目标选择器中的嵌套规则</span>
    <span class="hljs-attribute">color</span><span class="hljs-value">: blue;</span>
  }
}
<span class="hljs-class">.some-class</span><span class="hljs-value">:extend(.bucket tr) {} // 识别嵌套规则</span>
</code></pre>
<p>这会输出：</p>
<pre><code class="lang-css"><span class="hljs-class">.bucket</span> <span class="hljs-tag">tr</span>,
<span class="hljs-class">.some-class</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> blue</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>从本质上将extend会查找编译后的CSS，而不是原始的less。</p>
<p>示例：</p>
<pre><code class="lang-less"><span class="hljs-class">.bucket</span> {
  <span class="hljs-tag">tr</span> &amp; { <span class="hljs-comment">// 目标选择器中的嵌套</span>
    <span class="hljs-attribute">color</span><span class="hljs-value">: blue;</span>
  }
}
<span class="hljs-class">.some-class</span><span class="hljs-value">:extend(tr .bucket) {} // 识别嵌套规则</span>
</code></pre>
<p>输出：</p>
<pre><code class="lang-css"><span class="hljs-tag">tr</span> <span class="hljs-class">.bucket</span>,
<span class="hljs-class">.some-class</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> blue</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<h3 class="docs-heading">extend中的精确匹配<span class="anchor-target" id="extend-feature-extend-"></span>
<a href="#extend-feature-extend-" name="extend-feature-extend-" class="anchor glyphicon glyphicon-link"></a></h3>
<p>Extend默认会在选择器之间寻找精确匹配。它不管选择器是以星号开始还是不是。它也不管两个nth表达式是否具有相同的意义，它们必须以相同的形式匹配。唯一例外的是属性选择器中的引号，less会知道它们是相同的，然后匹配它。</p>
<p>示例：</p>
<pre><code class="lang-less"><span class="hljs-class">.a</span><span class="hljs-class">.class</span>,
<span class="hljs-class">.class</span><span class="hljs-class">.a</span>,
<span class="hljs-class">.class</span> &gt; <span class="hljs-class">.a</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: blue;</span>
}
<span class="hljs-class">.test</span><span class="hljs-value">:extend(.class) {} // 不会匹配上面的任何选择器的值</span>
</code></pre>
<p><em>号开头也是有关系的。选贼起`</em>.class<code>和</code>.class`是等价的，而extend不会匹配它们：</p>
<pre><code class="lang-less">*<span class="hljs-class">.class</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: blue;</span>
}
<span class="hljs-class">.noStar</span><span class="hljs-value">:extend(.class) {} 不会匹配*.class选择器</span>
</code></pre>
<p>输出：</p>
<pre><code class="lang-css">*<span class="hljs-class">.class</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> blue</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>伪类的顺序是有关系的。选择器<code>link:hover:visited</code>和<code>link:visited:hover</code>匹配相同的元素集合，但是extend会区别对待它们：</p>
<pre><code class="lang-less"><span class="hljs-tag">link</span><span class="hljs-pseudo">:hover</span><span class="hljs-pseudo">:visited</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: blue;</span>
}
<span class="hljs-class">.selector</span><span class="hljs-value">:extend(link:visited:hover) {}</span>
</code></pre>
<p>输出：</p>
<pre><code class="lang-css"><span class="hljs-tag">link</span><span class="hljs-pseudo">:hover</span><span class="hljs-pseudo">:visited</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> blue</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<h3 class="docs-heading">nth表达式<span class="anchor-target" id="extend-feature-nth-"></span>
<a href="#extend-feature-nth-" name="extend-feature-nth-" class="anchor glyphicon glyphicon-link"></a></h3>
<p>Nth形式的表达式也是有关系的。Nth表达式<code>1n+3</code>和<code>n+3</code>是等价的，但是extend并不能匹配它们：</p>
<pre><code class="lang-less"><span class="hljs-pseudo">:nth-child</span>(1n+3) {
  <span class="hljs-attribute">color</span><span class="hljs-value">: blue;</span>
}
<span class="hljs-class">.child</span><span class="hljs-value">:extend(n+<span class="hljs-number">3</span>) {}</span>
</code></pre>
<p>输出：</p>
<pre><code class="lang-css"><span class="hljs-pseudo">:nth-child(1n+3)</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> blue</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>属性选择器中的引号类型也是有关系的。以下所有都是等价的：</p>
<pre><code class="lang-less"><span class="hljs-attr_selector">[title=identifier]</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: blue;</span>
}
<span class="hljs-attr_selector">[title='identifier']</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: blue;</span>
}
<span class="hljs-attr_selector">[title="identifier"]</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: blue;</span>
}

<span class="hljs-class">.noQuote</span><span class="hljs-value">:extend([title=identifier]) {}
.singleQuote:extend([title=<span class="hljs-string">'identifier'</span>]) {}
.doubleQuote:extend([title=<span class="hljs-string">"identifier"</span>]) {}</span>
</code></pre>
<p>输出</p>
<pre><code class="lang-css"><span class="hljs-attr_selector">[title=identifier]</span>,
<span class="hljs-class">.noQuote</span>,
<span class="hljs-class">.singleQuote</span>,
<span class="hljs-class">.doubleQuote</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> blue</span></span>;
<span class="hljs-rule">}</span></span>

<span class="hljs-attr_selector">[title='identifier']</span>,
<span class="hljs-class">.noQuote</span>,
<span class="hljs-class">.singleQuote</span>,
<span class="hljs-class">.doubleQuote</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> blue</span></span>;
<span class="hljs-rule">}</span></span>

<span class="hljs-attr_selector">[title="identifier"]</span>,
<span class="hljs-class">.noQuote</span>,
<span class="hljs-class">.singleQuote</span>,
<span class="hljs-class">.doubleQuote</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> blue</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<h2 class="docs-heading">Extend &quot;all&quot;<span class="anchor-target" id="extend-feature-extend-all-"></span>
<a href="#extend-feature-extend-all-" name="extend-feature-extend-all-" class="anchor glyphicon glyphicon-link"></a></h2>
<p>当你在extend参数的最后面指定all关键字时，它会告诉告诉匹配作为其他选择器一部分的选择器。这个选择器会被复制，然后匹配的选择器部分会使用扩展替换，创建一个新的选择器。</p>
<p>示例：</p>
<pre><code class="lang-less"><span class="hljs-class">.a</span><span class="hljs-class">.b</span><span class="hljs-class">.test</span>,
<span class="hljs-class">.test</span><span class="hljs-class">.c</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: orange;</span>
}
<span class="hljs-class">.test</span> {
  &amp;<span class="hljs-pseudo">:hover</span> {
    <span class="hljs-attribute">color</span><span class="hljs-value">: green;</span>
  }
}

<span class="hljs-class">.replacement</span><span class="hljs-value">:extend(.test all) {}</span>
</code></pre>
<p>输出：</p>
<pre><code class="lang-css"><span class="hljs-class">.a</span><span class="hljs-class">.b</span><span class="hljs-class">.test</span>,
<span class="hljs-class">.test</span><span class="hljs-class">.c</span>,
<span class="hljs-class">.a</span><span class="hljs-class">.b</span><span class="hljs-class">.replacement</span>,
<span class="hljs-class">.replacement</span><span class="hljs-class">.c</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> orange</span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-class">.test</span><span class="hljs-pseudo">:hover</span>,
<span class="hljs-class">.replacement</span><span class="hljs-pseudo">:hover</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> green</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p><em>你可以认为这种操作模式就是无损搜索和替换。</em></p>
<h3 class="docs-heading">Extend中的选择器插值<span class="anchor-target" id="extend-feature-extend-"></span>
<a href="#extend-feature-extend-" name="extend-feature-extend-" class="anchor glyphicon glyphicon-link"></a></h3>
<blockquote>
<p>Extend不能匹配变量选择器。如果选择器包含变量，extend会忽略它。</p>
</blockquote>
<p>这是一个悬而未决的特性，改变它并不容易。然而，extend可以附加给插值选择器。</p>
<p>带变量的选择器不会匹配：</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@variable:<span class="hljs-preprocessor"> .bucket</span>;</span>
<span class="hljs-at_rule">@{</span>variable} { <span class="hljs-comment">// 插值选择器</span>
  <span class="hljs-attribute">color</span><span class="hljs-value">: blue;</span>
}
<span class="hljs-class">.some-class</span><span class="hljs-value">:extend(.bucket) {} // 找不到匹配</span>
</code></pre>
<p>同时在extend中使用目标选择器变量也什么都不匹配：</p>
<pre><code class="lang-less"><span class="hljs-class">.bucket</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: blue;</span>
}
<span class="hljs-class">.some-class</span><span class="hljs-value">:extend(@{variable}) {} // 插值选择器什么也不匹配
@variable: .bucket;</span>
</code></pre>
<p>上面两个例子都会编译为：</p>
<pre><code class="lang-less"><span class="hljs-class">.bucket</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: blue;</span>
}
</code></pre>
<p>然而, <code>:extend</code> 附加给插值选择器是能够工作的：</p>
<pre><code class="lang-less"><span class="hljs-class">.bucket</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: blue;</span>
}
<span class="hljs-at_rule">@{</span>variable}<span class="hljs-value">:extend(.bucket) {}
@variable: .selector;</span>
</code></pre>
<p>上面的例子会编译为：</p>
<pre><code class="lang-less"><span class="hljs-class">.bucket</span>, <span class="hljs-class">.selector</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: blue;</span>
}
</code></pre>
<h2 class="docs-heading">作用域/@media内的extend<span class="anchor-target" id="extend-feature--media-extend"></span>
<a href="#extend-feature--media-extend" name="extend-feature--media-extend" class="anchor glyphicon glyphicon-link"></a></h2>
<p>编写在media声明内的extend也应该只匹配同一media声明内的选择器：</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@<span class="hljs-keyword">media</span><span class="hljs-preprocessor"> print</span> {</span>
  <span class="hljs-class">.screenClass</span><span class="hljs-value">:extend(.selector) {} // media内的extend
  .selector { // 这个会匹配到-因为在同一的media内
    color: black;</span>
  }
}
<span class="hljs-class">.selector</span> { <span class="hljs-comment">// 定义样式表中的规则 - extend会忽略它</span>
  <span class="hljs-attribute">color</span><span class="hljs-value">: red;</span>
}
<span class="hljs-at_rule">@<span class="hljs-keyword">media</span><span class="hljs-preprocessor"> screen</span> {</span>
  <span class="hljs-class">.selector</span> {  <span class="hljs-comment">// 另一个media声明内的规则 - extend也会忽略它</span>
    <span class="hljs-attribute">color</span><span class="hljs-value">: blue;</span>
  }
}
</code></pre>
<p>最终编译为：</p>
<pre><code class="lang-css"><span class="hljs-at_rule">@<span class="hljs-keyword">media</span> print </span>{
  <span class="hljs-class">.selector</span>,
  <span class="hljs-class">.screenClass</span> <span class="hljs-rules">{ <span class="hljs-comment">/*  同一media内的规则扩展成功 */</span>
    <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> black</span></span>;
  <span class="hljs-rule">}</span></span>
}
<span class="hljs-class">.selector</span> <span class="hljs-rules">{ <span class="hljs-comment">/* 定义样式表中的规则被忽略 */</span>
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> red</span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-at_rule">@<span class="hljs-keyword">media</span> screen </span>{
  <span class="hljs-class">.selector</span> <span class="hljs-rules">{ <span class="hljs-comment">/* 其他media中的规则也被忽略 */</span>
    <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> blue</span></span>;
  <span class="hljs-rule">}</span></span>
}
</code></pre>
<p>编写在media声明内的extend不会匹配嵌套声明内的选择器：</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@<span class="hljs-keyword">media</span><span class="hljs-preprocessor"> screen</span> {</span>
  <span class="hljs-class">.screenClass</span><span class="hljs-value">:extend(.selector) {} // media内的extend
  @media (min-width: <span class="hljs-number">1023</span>px) {
    .selector {  // 嵌套media内的规则 - extend会忽略它
      color: blue;</span>
    }
  }
}
</code></pre>
<p>编译为：</p>
<pre><code class="lang-css"><span class="hljs-at_rule">@<span class="hljs-keyword">media</span> screen and (min-width: <span class="hljs-number">1023</span>px) </span>{
  <span class="hljs-class">.selector</span> <span class="hljs-rules">{ <span class="hljs-comment">/* 其他嵌套media内的规则被忽略 */</span>
    <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> blue</span></span>;
  <span class="hljs-rule">}</span></span>
}
</code></pre>
<p>顶级extend匹配一切，包括media嵌套内的选择器：</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@<span class="hljs-keyword">media</span><span class="hljs-preprocessor"> screen</span> {</span>
  <span class="hljs-class">.selector</span> {  <span class="hljs-comment">/* media嵌套内的规则 - 顶级extend正常工作 */</span>
    <span class="hljs-attribute">color</span><span class="hljs-value">: blue;</span>
  }
  <span class="hljs-at_rule">@<span class="hljs-keyword">media</span> (min-width:<span class="hljs-preprocessor"> 1023px</span>) {</span>
    <span class="hljs-class">.selector</span> {  <span class="hljs-comment">/* media嵌套内的规则 - 顶级extend正常工作 */</span>
      <span class="hljs-attribute">color</span><span class="hljs-value">: blue;</span>
    }
  }
}

<span class="hljs-class">.topLevel</span><span class="hljs-value">:extend(.selector) {} /* 顶级extend匹配一切 */</span>
</code></pre>
<p>编译为：</p>
<pre><code class="lang-css"><span class="hljs-at_rule">@<span class="hljs-keyword">media</span> screen </span>{
  <span class="hljs-class">.selector</span>,
  <span class="hljs-class">.topLevel</span> <span class="hljs-rules">{ <span class="hljs-comment">/* media嵌套内的规则被扩展了 */</span>
    <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> blue</span></span>;
  <span class="hljs-rule">}</span></span>
}
<span class="hljs-at_rule">@<span class="hljs-keyword">media</span> screen and (min-width: <span class="hljs-number">1023</span>px) </span>{
  <span class="hljs-class">.selector</span>,
  <span class="hljs-class">.topLevel</span> <span class="hljs-rules">{ <span class="hljs-comment">/* media嵌套内的规则被扩展了 */</span>
    <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> blue</span></span>;
  <span class="hljs-rule">}</span></span>
}
</code></pre>
<h3 class="docs-heading">检测重复<span class="anchor-target" id="extend-feature--"></span>
<a href="#extend-feature--" name="extend-feature--" class="anchor glyphicon glyphicon-link"></a></h3>
<p>现在，这里还没有检测重复。</p>
<p>示例：</p>
<pre><code class="lang-less"><span class="hljs-class">.alert-info</span>,
<span class="hljs-class">.widget</span> {
  <span class="hljs-comment">/* declarations */</span>
}

<span class="hljs-class">.alert</span><span class="hljs-value">:extend(.alert-info, .widget) {}</span>
</code></pre>
<p>输出：</p>
<pre><code class="lang-css"><span class="hljs-class">.alert-info</span>,
<span class="hljs-class">.widget</span>,
<span class="hljs-class">.alert</span>,
<span class="hljs-class">.alert</span> <span class="hljs-rules">{
  <span class="hljs-comment">/* declarations */</span>
<span class="hljs-rule">}</span></span>
</code></pre>
<h2 class="docs-heading">Extend用例<span class="anchor-target" id="extend-feature-extend-"></span>
<a href="#extend-feature-extend-" name="extend-feature-extend-" class="anchor glyphicon glyphicon-link"></a></h2>
<h3 class="docs-heading">经典用例<span class="anchor-target" id="extend-feature--"></span>
<a href="#extend-feature--" name="extend-feature--" class="anchor glyphicon glyphicon-link"></a></h3>
<p>经典用于就是避免添加基础类。比如，如果你有：</p>
<pre><code class="lang-css"><span class="hljs-class">.animal</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">background-color</span>:<span class="hljs-value"> black</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> white</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>如果你想有一个animal子类型，并且要重写背景颜色。那么你有两个选择，首先改变你的HTML</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"animal bear"</span>&gt;</span>Bear<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>
</code></pre>
<pre><code class="lang-css"><span class="hljs-class">.animal</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">background-color</span>:<span class="hljs-value"> black</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> white</span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-class">.bear</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">background-color</span>:<span class="hljs-value"> brown</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>或者简化HTML，然后在你的less中使用extend，比如：</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"bear"</span>&gt;</span>Bear<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>
</code></pre>
<pre><code class="lang-less"><span class="hljs-class">.animal</span> {
  <span class="hljs-attribute">background-color</span><span class="hljs-value">: black;</span>
  <span class="hljs-attribute">color</span><span class="hljs-value">: white;</span>
}
<span class="hljs-class">.bear</span> {
  &amp;<span class="hljs-value">:extend(.animal);</span>
  <span class="hljs-attribute">background-color</span><span class="hljs-value">: brown;</span>
}
</code></pre>
<h3 class="docs-heading">CSS尺寸归并<span class="anchor-target" id="extend-feature-css-"></span>
<a href="#extend-feature-css-" name="extend-feature-css-" class="anchor glyphicon glyphicon-link"></a></h3>
<p>Mixins会复制所有的属性到选择器中，这可能导致不必要的重复。因此你可以使用extend来代替mixin将你要用的属性移过去，这样就会生成更少的CSS。</p>
<p>mixin示例：</p>
<pre><code class="lang-less"><span class="hljs-class">.my-inline-block</span>() {
    <span class="hljs-attribute">display</span><span class="hljs-value">: inline-block;</span>
  <span class="hljs-attribute">font-size</span><span class="hljs-value">: <span class="hljs-number">0</span>;</span>
}
<span class="hljs-class">.thing1</span> {
  <span class="hljs-class">.my-inline-block</span>;
}
<span class="hljs-class">.thing2</span> {
  <span class="hljs-class">.my-inline-block</span>;
}
</code></pre>
<p>输出：</p>
<pre><code class="lang-css"><span class="hljs-class">.thing1</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">display</span>:<span class="hljs-value"> inline-block</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">font-size</span>:<span class="hljs-value"> <span class="hljs-number">0</span></span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-class">.thing2</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">display</span>:<span class="hljs-value"> inline-block</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">font-size</span>:<span class="hljs-value"> <span class="hljs-number">0</span></span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>extend示例：</p>
<pre><code class="lang-less"><span class="hljs-class">.my-inline-block</span> {
  <span class="hljs-attribute">display</span><span class="hljs-value">: inline-block;</span>
  <span class="hljs-attribute">font-size</span><span class="hljs-value">: <span class="hljs-number">0</span>;</span>
}
<span class="hljs-class">.thing1</span> {
  &amp;<span class="hljs-value">:extend(.my-inline-block);</span>
}
<span class="hljs-class">.thing2</span> {
  &amp;<span class="hljs-value">:extend(.my-inline-block);</span>
}
</code></pre>
<p>输出：</p>
<pre><code class="lang-css"><span class="hljs-class">.my-inline-block</span>,
<span class="hljs-class">.thing1</span>,
<span class="hljs-class">.thing2</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">display</span>:<span class="hljs-value"> inline-block</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">font-size</span>:<span class="hljs-value"> <span class="hljs-number">0</span></span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<h3 class="docs-heading">合并样式/更高级的mixin<span class="anchor-target" id="extend-feature--mixin"></span>
<a href="#extend-feature--mixin" name="extend-feature--mixin" class="anchor glyphicon glyphicon-link"></a></h3>
<p>另一个用例可以用作mixin的替代 - 因为mixin仅仅能用于简单的选择器，如果你的html中有两个不同的块，但是你需要为这两个块应用相同的样式，那么你可以使用extend来关联这两块。</p>
<p>示例：</p>
<pre><code class="lang-less"><span class="hljs-tag">li</span><span class="hljs-class">.list</span> &gt; <span class="hljs-tag">a</span> {
  <span class="hljs-comment">// list styles</span>
}
<span class="hljs-tag">button</span><span class="hljs-class">.list-style</span> {
  &amp;<span class="hljs-value">:extend(li.list &gt; a);</span> <span class="hljs-comment">// 使用相同的列表样式</span>
}
</code></pre>


      <br>
    </div>
    

  </div>

  <!-- Mixins -->
  <div class="docs-section">
    <div class="page-header">
      <h1 class="docs-heading">Mixins<span class="anchor-target" id="mixins-feature"></span>
<a href="#mixins-feature" name="mixins-feature" class="anchor glyphicon glyphicon-link"></a></h1>
    </div>

    
    <div class="section-content">
      
<a class="glyphicon glyphicon-pencil source-link right" href="/blob//content_zh/features/mixins.md" data-content="mixinsmd" target="_blank"></a>



<a id="mixinsmd" href="/blob//content_zh/features/mixins.md" target="_blank">Edit the markdown source for "mixins"
  <span class="glyphicon glyphicon-new-window"></span>
</a>

      <!-- mixins -->
       


<blockquote>
<p>从现有的样式混合（mixin）属性</p>
</blockquote>
<p>你可以混合“类”选择器或者“id”选择器，例如：</p>
<pre><code class="lang-less"><span class="hljs-class">.a</span>, <span class="hljs-id">#b</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: red;</span>
}
<span class="hljs-class">.mixin-class</span> {
  <span class="hljs-class">.a</span>();
}
<span class="hljs-class">.mixin-id</span> {
  <span class="hljs-id">#b</span>();
}
</code></pre>
<p>以上将得到:</p>
<pre><code class="lang-css"><span class="hljs-class">.a</span>, <span class="hljs-id">#b</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> red</span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-class">.mixin-class</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> red</span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-class">.mixin-id</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> red</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p><em>（小提示：当你调用混合集的时候，括号可加可不加）</em></p>
<pre><code class="lang-less"><span class="hljs-class">.a</span>();   <span class="hljs-comment">//这两种调用方式效果是一样的</span>
<span class="hljs-class">.a</span>;
</code></pre>
<h2 class="docs-heading">不输出混合集<span class="anchor-target" id="mixins-feature--"></span>
<a href="#mixins-feature--" name="mixins-feature--" class="anchor glyphicon glyphicon-link"></a></h2>
<p>如果你想要创建一个混合集，但是却不想让它输出到你的样式中，你可以在混合集的名字后面加上一个括号。</p>
<pre><code class="lang-less"><span class="hljs-class">.my-mixin</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: black;</span>
}
<span class="hljs-class">.my-other-mixin</span>() {
  <span class="hljs-attribute">background</span><span class="hljs-value">: white;</span>
}
<span class="hljs-class">.class</span> {
  <span class="hljs-class">.my-mixin</span>;
  <span class="hljs-class">.my-other-mixin</span>;
}
</code></pre>
<p>结果为：</p>
<pre><code class="lang-css"><span class="hljs-class">.my-mixin</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> black</span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-class">.class</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> black</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">background</span>:<span class="hljs-value"> white</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<h2 class="docs-heading">带选择器的混合集<span class="anchor-target" id="mixins-feature--"></span>
<a href="#mixins-feature--" name="mixins-feature--" class="anchor glyphicon glyphicon-link"></a></h2>
<p>混合集不仅可以包含各种属性，而且可以包括各种选择器。</p>
<p>例如：</p>
<pre><code class="lang-less"><span class="hljs-class">.my-hover-mixin</span>() {
  &amp;<span class="hljs-pseudo">:hover</span> {
    <span class="hljs-attribute">border</span><span class="hljs-value">: <span class="hljs-number">1</span>px solid red;</span>
  }
}
<span class="hljs-tag">button</span> {
  <span class="hljs-class">.my-hover-mixin</span>();
}
</code></pre>
<p>结果为：</p>
<pre><code class="lang-css"><span class="hljs-tag">button</span><span class="hljs-pseudo">:hover</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">border</span>:<span class="hljs-value"> <span class="hljs-number">1</span>px solid red</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<h2 class="docs-heading">命名空间<span class="anchor-target" id="mixins-feature--"></span>
<a href="#mixins-feature--" name="mixins-feature--" class="anchor glyphicon glyphicon-link"></a></h2>
<p>如果你想要将属性混合到比较复杂的选择器中，你可以通过嵌套多层id或者class。</p>
<pre><code class="lang-less"><span class="hljs-id">#outer</span> {
  <span class="hljs-class">.inner</span> {
    <span class="hljs-attribute">color</span><span class="hljs-value">: red;</span>
  }
}

<span class="hljs-class">.c</span> {
  <span class="hljs-id">#outer</span> &gt; <span class="hljs-class">.inner</span>;
}
</code></pre>
<p>同样 <code>&gt;</code> 是可选的</p>
<pre><code class="lang-less"><span class="hljs-comment">// 下面四种写法效果是一样的</span>
<span class="hljs-id">#outer</span> &gt; <span class="hljs-class">.inner</span>;
<span class="hljs-id">#outer</span> &gt; <span class="hljs-class">.inner</span>();
<span class="hljs-id">#outer</span><span class="hljs-class">.inner</span>;
<span class="hljs-id">#outer</span><span class="hljs-class">.inner</span>();
</code></pre>
<p>这种用法的效果相当于我们熟知的命名空间，你可以把混合集放到一个id选择器里面，这样可以确保它（这个混合集）不会跟其他的库冲突。</p>
<p>例如：</p>
<pre><code class="lang-less"><span class="hljs-id">#my-library</span> {
  <span class="hljs-class">.my-mixin</span>() {
    <span class="hljs-attribute">color</span><span class="hljs-value">: black;</span>
  }
}
<span class="hljs-comment">// 可以这样调用</span>
<span class="hljs-class">.class</span> {
  <span class="hljs-id">#my-library</span> &gt; <span class="hljs-class">.my-mixin</span>();
}
</code></pre>
<h2 class="docs-heading"><code>!important</code> 关键字<span class="anchor-target" id="mixins-feature--important-"></span>
<a href="#mixins-feature--important-" name="mixins-feature--important-" class="anchor glyphicon glyphicon-link"></a></h2>
<p>在调用的混合集后面追加 <code>!important</code> 关键字，可以使混合集里面的所有属性都继承 <code>!important</code>：</p>
<p>例如：</p>
<pre><code class="lang-less"><span class="hljs-class">.foo</span> (<span class="hljs-at_rule">@bg: <span class="hljs-hexcolor">#f5f5f5</span>, @color: <span class="hljs-hexcolor">#900</span>) {</span>
  <span class="hljs-attribute">background</span><span class="hljs-value">: @bg;</span>
  <span class="hljs-attribute">color</span><span class="hljs-value">: @color;</span>
}
<span class="hljs-class">.unimportant</span> {
  <span class="hljs-class">.foo</span>();
}
<span class="hljs-class">.important</span> {
  <span class="hljs-class">.foo</span>() !important;
}
</code></pre>
<p>结果为:</p>
<pre><code class="lang-css"><span class="hljs-class">.unimportant</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">background</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#f5f5f5</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#900</span></span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-class">.important</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">background</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#f5f5f5</span> <span class="hljs-important">!important</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#900</span> <span class="hljs-important">!important</span></span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>


      <br>
    </div>
    

  </div>

  <!-- Parametric Mixins -->
  <div class="docs-section">
    <div class="page-header">
      <h1 class="docs-heading">Parametric Mixins<span class="anchor-target" id="mixins-parametric-feature"></span>
<a href="#mixins-parametric-feature" name="mixins-parametric-feature" class="anchor glyphicon glyphicon-link"></a></h1>
    </div>

    
    <div class="section-content">
      
<a class="glyphicon glyphicon-pencil source-link right" href="/blob//content_zh/features/mixins-parametric.md" data-content="mixins-parametricmd" target="_blank"></a>



<a id="mixins-parametricmd" href="/blob//content_zh/features/mixins-parametric.md" target="_blank">Edit the markdown source for "mixins-parametric"
  <span class="glyphicon glyphicon-new-window"></span>
</a>

      <!-- mixins-parametric -->
       


<blockquote>
<p>如何给mixins传递参数</p>
</blockquote>
<p>mixins也可以接受参数，在它进行mix in操作时会将变量传递给选择器代码块。</p>
<p>比如：</p>
<pre><code class="lang-less"><span class="hljs-class">.border-radius</span>(<span class="hljs-at_rule">@radius) {</span>
  -webkit-<span class="hljs-attribute">border-radius</span><span class="hljs-value">: @radius;</span>
     -moz-<span class="hljs-attribute">border-radius</span><span class="hljs-value">: @radius;</span>
          <span class="hljs-attribute">border-radius</span><span class="hljs-value">: @radius;</span>
}
</code></pre>
<p>接下来，你可以在系一些规则集中混入变量值：</p>
<pre><code class="lang-less"><span class="hljs-id">#header</span> {
  <span class="hljs-class">.border-radius</span>(4px);
}
<span class="hljs-class">.button</span> {
  <span class="hljs-class">.border-radius</span>(6px);
}
</code></pre>
<p>对于这些进行mixin操作的参数也可以有默认值：</p>
<pre><code class="lang-less"><span class="hljs-class">.border-radius</span>(<span class="hljs-at_rule">@radius:<span class="hljs-preprocessor"> 5px</span>) {</span>
  -webkit-<span class="hljs-attribute">border-radius</span><span class="hljs-value">: @radius;</span>
     -moz-<span class="hljs-attribute">border-radius</span><span class="hljs-value">: @radius;</span>
          <span class="hljs-attribute">border-radius</span><span class="hljs-value">: @radius;</span>
}
</code></pre>
<p>然后你可以像这样调用它：</p>
<pre><code class="lang-less"><span class="hljs-id">#header</span> {
  <span class="hljs-class">.border-radius</span>;
}
</code></pre>
<p>这里仍然会包含一个5px的border-radius。</p>
<p>你也可以使用不接受参数的mixins。如果你想从输出的CSS中隐藏规则集，但是又想在其他规则集中包含它的属性，这个特性是很有用的：</p>
<pre><code class="lang-less"><span class="hljs-class">.wrap</span>() {
  <span class="hljs-value">text</span>-wrap<span class="hljs-value">: wrap;</span>
  <span class="hljs-attribute">white-space</span><span class="hljs-value">: -moz-pre-wrap;</span>
  <span class="hljs-attribute">white-space</span><span class="hljs-value">: pre-wrap;</span>
  <span class="hljs-attribute">word-wrap</span><span class="hljs-value">: break-word;</span>
}

<span class="hljs-tag">pre</span> { <span class="hljs-class">.wrap</span> }
</code></pre>
<p>这会输出：</p>
<pre><code class="lang-css"><span class="hljs-tag">pre</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">text-wrap</span>:<span class="hljs-value"> wrap</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">white-space</span>:<span class="hljs-value"> -moz-pre-wrap</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">white-space</span>:<span class="hljs-value"> pre-wrap</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">word-wrap</span>:<span class="hljs-value"> break-word</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<h3 class="docs-heading">带多个参数的mixins<span class="anchor-target" id="mixins-parametric-feature--mixins"></span>
<a href="#mixins-parametric-feature--mixins" name="mixins-parametric-feature--mixins" class="anchor glyphicon glyphicon-link"></a></h3>
<p>参数可以用<em>分号</em>或者<em>逗号</em>分割。但是推荐使用<em>分号</em>分割。因为逗号符号有两个意思：它可以解释为mixins参数分隔符或者css列表分隔符。</p>
<p>使用逗号作为mixin的分隔符则无法用它创建逗号分割的参数列表。换句话说，如果编译器在mixin调用或者声明中看到至少一个分号，它会假设参数是由分号分割的，而所有的逗号都属于CSS列表:</p>
<ul>
<li>两个参数，并且每个参数都是逗号分割的列表：<code>.name(1,2,3;something, ele)</code>，</li>
<li>三个参数，并且每个参数都包含一个数字：<code>.name(1,2,3)</code>，</li>
<li>使用伪造的分号创建mixin，调用的时候参数包含一个逗号分割的css列表：<code>.name(1,2,3;)</code>，</li>
<li>逗号分割默认值：<code>.name(@param1: red, blue)</code>。</li>
</ul>
<p>定义多个具有相同名称和参数数量的mixins是合法的。Less会使用它可以应用的属性。如果使用mixin的时候只带一个参数，比如<code>.mixin(green)</code>，这个属性会导致所有的mixin都会使用强制使用这个明确的参数：</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span>(<span class="hljs-at_rule">@color) {</span>
  <span class="hljs-attribute">color</span>-1<span class="hljs-value">: @color;</span>
}
<span class="hljs-class">.mixin</span>(<span class="hljs-at_rule">@color;</span> <span class="hljs-at_rule">@padding:<span class="hljs-number">2</span>) {</span>
  <span class="hljs-attribute">color</span>-2<span class="hljs-value">: @color;</span>
  <span class="hljs-attribute">padding</span>-2<span class="hljs-value">: @padding;</span>
}
<span class="hljs-class">.mixin</span>(<span class="hljs-at_rule">@color;</span> <span class="hljs-at_rule">@padding;</span> <span class="hljs-at_rule">@margin:<span class="hljs-preprocessor"> 2</span>) {</span>
  <span class="hljs-attribute">color</span>-3<span class="hljs-value">: @color;</span>
  <span class="hljs-attribute">padding</span>-3<span class="hljs-value">: @padding;</span>
  <span class="hljs-attribute">margin</span><span class="hljs-value">: @margin @margin @margin @margin;</span>
}
<span class="hljs-class">.some</span> <span class="hljs-class">.selector</span> <span class="hljs-tag">div</span> {
  <span class="hljs-class">.mixin</span>(<span class="hljs-id">#008000</span>);
}
</code></pre>
<p>会编译为:</p>
<pre><code class="lang-css">.some .selector div {
  color-1: #008000;
  color-2: #008000;
  padding-2: 2;
}
</code></pre>
<h3 class="docs-heading">命名参数<span class="anchor-target" id="mixins-parametric-feature--"></span>
<a href="#mixins-parametric-feature--" name="mixins-parametric-feature--" class="anchor glyphicon glyphicon-link"></a></h3>
<p>引用mixin时可以通过参数名称而不是参数的位置来为mixin提供参数值。任何参数都已通过它的名称来引用，这样就不必按照任意特定的顺序来使用参数：</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span>(<span class="hljs-at_rule">@color:<span class="hljs-preprocessor"> black</span>;</span> <span class="hljs-at_rule">@margin:<span class="hljs-preprocessor"> 10px</span>;</span> <span class="hljs-at_rule">@padding:<span class="hljs-preprocessor"> 20px</span>) {</span>
  <span class="hljs-attribute">color</span><span class="hljs-value">: @color;</span>
  <span class="hljs-attribute">margin</span><span class="hljs-value">: @margin;</span>
  <span class="hljs-attribute">padding</span><span class="hljs-value">: @padding;</span>
}
<span class="hljs-class">.class1</span> {
  <span class="hljs-class">.mixin</span>(<span class="hljs-at_rule">@margin:<span class="hljs-preprocessor"> 20px</span>;</span> <span class="hljs-at_rule">@color: <span class="hljs-hexcolor">#33acfe</span>);</span>
}
<span class="hljs-class">.class2</span> {
  <span class="hljs-class">.mixin</span>(<span class="hljs-id">#efca44</span>; <span class="hljs-at_rule">@padding:<span class="hljs-preprocessor"> 40px</span>);</span>
}
</code></pre>
<p>会编译为：</p>
<pre><code class="lang-css"><span class="hljs-class">.class1</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#33acfe</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">margin</span>:<span class="hljs-value"> <span class="hljs-number">20</span>px</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">padding</span>:<span class="hljs-value"> <span class="hljs-number">20</span>px</span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-class">.class2</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#efca44</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">margin</span>:<span class="hljs-value"> <span class="hljs-number">10</span>px</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">padding</span>:<span class="hljs-value"> <span class="hljs-number">40</span>px</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<h3 class="docs-heading"><code>@arguments</code> 变量<span class="anchor-target" id="mixins-parametric-feature--arguments-"></span>
<a href="#mixins-parametric-feature--arguments-" name="mixins-parametric-feature--arguments-" class="anchor glyphicon glyphicon-link"></a></h3>
<p><code>@arguments</code>在mixins内部有特殊意义，调用mixin时，它包含所有传入的参数。如果你不想单个单个的处理参数，这一特性是很有用的：</p>
<pre><code class="lang-less"><span class="hljs-class">.box-shadow</span>(<span class="hljs-at_rule">@x:<span class="hljs-preprocessor"> 0</span>;</span> <span class="hljs-at_rule">@y:<span class="hljs-preprocessor"> 0</span>;</span> <span class="hljs-at_rule">@blur:<span class="hljs-preprocessor"> 1px</span>;</span> <span class="hljs-at_rule">@color: <span class="hljs-hexcolor">#000</span>) {</span>
  -webkit-<span class="hljs-attribute">box-shadow</span><span class="hljs-value">: @arguments;</span>
     -moz-<span class="hljs-attribute">box-shadow</span><span class="hljs-value">: @arguments;</span>
          <span class="hljs-attribute">box-shadow</span><span class="hljs-value">: @arguments;</span>
}
<span class="hljs-class">.big-block</span> {
  <span class="hljs-class">.box-shadow</span>(2px; 5px);
}
</code></pre>
<p>返回结果为：</p>
<pre><code class="lang-css"><span class="hljs-class">.big-block</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">-webkit-box-shadow</span>:<span class="hljs-value"> <span class="hljs-number">2</span>px <span class="hljs-number">5</span>px <span class="hljs-number">1</span>px <span class="hljs-hexcolor">#000</span></span></span>;
     <span class="hljs-rule"><span class="hljs-attribute">-moz-box-shadow</span>:<span class="hljs-value"> <span class="hljs-number">2</span>px <span class="hljs-number">5</span>px <span class="hljs-number">1</span>px <span class="hljs-hexcolor">#000</span></span></span>;
          <span class="hljs-rule"><span class="hljs-attribute">box-shadow</span>:<span class="hljs-value"> <span class="hljs-number">2</span>px <span class="hljs-number">5</span>px <span class="hljs-number">1</span>px <span class="hljs-hexcolor">#000</span></span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<h3 class="docs-heading">高级参数和<code>@rest</code>变量<span class="anchor-target" id="mixins-parametric-feature--rest-"></span>
<a href="#mixins-parametric-feature--rest-" name="mixins-parametric-feature--rest-" class="anchor glyphicon glyphicon-link"></a></h3>
<p>如果你希望你的mixin接受数量不定的参数，你可以使用<code>...</code>。在变量名后面使用它，它会将这些参数分配给变量。</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span>(...) {        <span class="hljs-comment">// matches 0-N arguments</span>
<span class="hljs-class">.mixin</span>() {           <span class="hljs-comment">// matches exactly 0 arguments</span>
<span class="hljs-class">.mixin</span>(<span class="hljs-at_rule">@a:<span class="hljs-preprocessor"> 1</span>) {</span>      <span class="hljs-comment">// matches 0-1 arguments</span>
<span class="hljs-class">.mixin</span>(<span class="hljs-at_rule">@a:<span class="hljs-preprocessor"> 1</span>;</span> ...) { <span class="hljs-comment">// matches 0-N arguments</span>
<span class="hljs-class">.mixin</span>(<span class="hljs-at_rule">@a;</span> ...) {    <span class="hljs-comment">// matches 1-N arguments</span>
</code></pre>
<p>此外：</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span>(<span class="hljs-at_rule">@a;</span> <span class="hljs-at_rule">@rest...) {</span>
   <span class="hljs-comment">// @rest 会绑定到参数 @a 之后</span>
   <span class="hljs-comment">// 而@arguments是绑定所有参数</span>
}
</code></pre>
<h2 class="docs-heading">模式匹配<span class="anchor-target" id="mixins-parametric-feature--"></span>
<a href="#mixins-parametric-feature--" name="mixins-parametric-feature--" class="anchor glyphicon glyphicon-link"></a></h2>
<p>有时候，你可能想要基于你传递给它的参数改变mixin的行为。先来看一些基础的示例：</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span>(<span class="hljs-at_rule">@s;</span> <span class="hljs-at_rule">@color) {</span> ... }

<span class="hljs-class">.class</span> {
  <span class="hljs-class">.mixin</span>(<span class="hljs-at_rule">@switch;</span> <span class="hljs-id">#888</span>);
}
</code></pre>
<p>现在，比方说你想要<code>.mixin</code>基于<code>@switch</code>的值以不同的方式表现，你可这样定义这个<code>mixin</code>：</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span>(dark; <span class="hljs-at_rule">@color) {</span>
  <span class="hljs-attribute">color</span><span class="hljs-value">: darken(@color, <span class="hljs-number">10</span>%);</span>
}
<span class="hljs-class">.mixin</span>(light; <span class="hljs-at_rule">@color) {</span>
  <span class="hljs-attribute">color</span><span class="hljs-value">: lighten(@color, <span class="hljs-number">10</span>%);</span>
}
<span class="hljs-class">.mixin</span>(<span class="hljs-at_rule">@_;</span> <span class="hljs-at_rule">@color) {</span>
  <span class="hljs-attribute">display</span><span class="hljs-value">: block;</span>
}
</code></pre>
<p>现在，如果运行它：</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@switch:<span class="hljs-preprocessor"> light</span>;</span>

<span class="hljs-class">.class</span> {
  <span class="hljs-class">.mixin</span>(<span class="hljs-at_rule">@switch;</span> <span class="hljs-id">#888</span>);
}
</code></pre>
<p>这将得到如下CSS：</p>
<pre><code class="lang-css"><span class="hljs-class">.class</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#a2a2a2</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">display</span>:<span class="hljs-value"> block</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>这里传递给<code>.mixin</code>的贪色变淡了。如果<code>@switch</code>的值是<code>dark</code>，结果会变成暗色。</p>
<p>这里发生了什么：</p>
<ul>
<li>第一个mixin定义并没有匹配，因为它期望第一个参数是<code>dark</code>。</li>
<li>第二个mixin定义匹配了，因为它接受的参数是预期的<code>light</code>。</li>
<li>第三个mixin定义也匹配了，因为它任何值都在其预料只用。</li>
</ul>
<p>这里只会使用匹配的mixin。变量匹配，然后绑定给任意变量。</p>
<p>除了变量匹配，只有一个值与其自身相等。</p>
<p>你也可以基于参数数量来匹配，这里有个例子：</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span>(<span class="hljs-at_rule">@a) {</span>
  <span class="hljs-attribute">color</span><span class="hljs-value">: @a;</span>
}
<span class="hljs-class">.mixin</span>(<span class="hljs-at_rule">@a;</span> <span class="hljs-at_rule">@b) {</span>
  <span class="hljs-attribute">color</span><span class="hljs-value">: fade(@a;</span> <span class="hljs-at_rule">@b);</span>
}
</code></pre>
<p>现在，如果我们用一个参数来调用<code>.mixin</code>，这将会输出第一个定义，但是如果我们使用<em>两个</em>参数调用它，这回获取第二个定义，这就是<code>@a</code>淡入到<code>@b</code>。</p>


      <br>
    </div>
    

  </div>

  <!-- Mixins as Functions -->
  <div class="docs-section">
    <div class="page-header">
      <h1 class="docs-heading">Mixins as Functions<span class="anchor-target" id="mixins-as-functions-feature"></span>
<a href="#mixins-as-functions-feature" name="mixins-as-functions-feature" class="anchor glyphicon glyphicon-link"></a></h1>
    </div>

    
    <div class="section-content">
      
<a class="glyphicon glyphicon-pencil source-link right" href="/blob//content_zh/features/mixins-as-functions.md" data-content="mixins-as-functionsmd" target="_blank"></a>



<a id="mixins-as-functionsmd" href="/blob//content_zh/features/mixins-as-functions.md" target="_blank">Edit the markdown source for "mixins-as-functions"
  <span class="glyphicon glyphicon-new-window"></span>
</a>

      <!-- mixins-as-functions -->
       


<blockquote>
<p>从mixin中返回变量</p>
</blockquote>
<p>所有定义在一个mixin中的变量都是可见的，还可以用于调用它的作用域中（除非调用它的作用域定义了同名变量）。</p>
<p>示例：</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span>() {
  <span class="hljs-at_rule">@width: <span class="hljs-preprocessor"> 100</span>%;</span>
  <span class="hljs-at_rule">@height:<span class="hljs-preprocessor"> 200px</span>;</span>
}

<span class="hljs-class">.caller</span> {
  <span class="hljs-class">.mixin</span>();
  <span class="hljs-attribute">width</span><span class="hljs-value">:  @width;</span>
  <span class="hljs-attribute">height</span><span class="hljs-value">: @height;</span>
}
</code></pre>
<p>结果：</p>
<pre><code class="lang-css"><span class="hljs-class">.caller</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value">  <span class="hljs-number">100</span>%</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value"> <span class="hljs-number">200</span>px</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>因此定义在mixin中的变量还可以充当它的返回值。这样就允许我们创建一个用起来类似函数的mixin。</p>
<p>示例：</p>
<pre><code class="lang-less"><span class="hljs-class">.average</span>(<span class="hljs-at_rule">@x, @y) {</span>
  <span class="hljs-at_rule">@average: ((@x + @y) /<span class="hljs-preprocessor"> 2</span>);</span>
}

<span class="hljs-tag">div</span> {
  <span class="hljs-class">.average</span>(16px, 50px); <span class="hljs-comment">// "call" the mixin</span>
  <span class="hljs-attribute">padding</span><span class="hljs-value">: @average;</span>    <span class="hljs-comment">// use its "return" value</span>
}
</code></pre>
<p>结果：</p>
<pre><code class="lang-css"><span class="hljs-tag">div</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">padding</span>:<span class="hljs-value"> <span class="hljs-number">33</span>px</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>


      <br>
    </div>
    

  </div>

  <!-- Passing Rulesets to Mixins -->
  <div class="docs-section">
    <div class="page-header">
      <h1 class="docs-heading">Passing Rulesets to Mixins<span class="anchor-target" id="detached-rulesets-feature"></span>
<a href="#detached-rulesets-feature" name="detached-rulesets-feature" class="anchor glyphicon glyphicon-link"></a></h1>
    </div>

    
    <div class="section-content">
      
<a class="glyphicon glyphicon-pencil source-link right" href="/blob//content_zh/features/detached-rulesets.md" data-content="detached-rulesetsmd" target="_blank"></a>



<a id="detached-rulesetsmd" href="/blob//content_zh/features/detached-rulesets.md" target="_blank">Edit the markdown source for "detached-rulesets"
  <span class="glyphicon glyphicon-new-window"></span>
</a>

      <!-- detached-rulesets -->
       


<blockquote>
<p>允许在mixin中定义包装的CSS块</p>
</blockquote>
<p>发布于 <a href="https://github.com/less/less.js/blob/masterCHANGELOG.md">v1.7.0</a></p>
<p>你可能希望定义一个mixin将一个媒体查询中的一个代码块或者一个浏览器不支持的类名抽象出来。现在，你可以传递规则集给mixin，然后该mixin会包装这些规则集。比如：</p>
<pre><code class="lang-less"><span class="hljs-class">.desktop-and-old-ie</span>(<span class="hljs-at_rule">@rules) {</span>
  <span class="hljs-at_rule">@<span class="hljs-keyword">media</span><span class="hljs-preprocessor"> screen</span><span class="hljs-preprocessor"> and</span> (min-width:<span class="hljs-preprocessor"> 1200</span>) {</span> <span class="hljs-at_rule">@<span class="hljs-function">rules()</span>;</span> }
  <span class="hljs-tag">html</span><span class="hljs-class">.lt-ie9</span> &amp;                       { <span class="hljs-at_rule">@<span class="hljs-function">rules()</span>;</span> }
}

<span class="hljs-tag">header</span> {
  <span class="hljs-attribute">background-color</span><span class="hljs-value">: blue;</span>

  <span class="hljs-class">.desktop-and-old-ie</span>({
    <span class="hljs-attribute">background-color</span><span class="hljs-value">: red;</span>
  });
}
</code></pre>
<p>这里的<code>desktop-and-old-ie</code> mixin定义了媒体查询和祖先类，因此你可以使用mixin来包装一段代码。上面这段代码会输出：</p>
<pre><code class="lang-css"><span class="hljs-tag">header</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">background-color</span>:<span class="hljs-value"> blue</span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-at_rule">@<span class="hljs-keyword">media</span> screen and (min-width: <span class="hljs-number">1200</span>) </span>{
  <span class="hljs-tag">header</span> <span class="hljs-rules">{
    <span class="hljs-rule"><span class="hljs-attribute">background-color</span>:<span class="hljs-value"> red</span></span>;
  <span class="hljs-rule">}</span></span>
}
<span class="hljs-tag">html</span><span class="hljs-class">.lt-ie9</span> <span class="hljs-tag">header</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">background-color</span>:<span class="hljs-value"> red</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>A ruleset can be now assigned to a variable or passed in to a mixin and can contain the full set of less features, e.g.</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@my-ruleset: {</span>
    <span class="hljs-class">.my-selector</span> {
      <span class="hljs-attribute">background-color</span><span class="hljs-value">: black;</span>
    }
  };
</code></pre>
<p>You can even take advantage of <a href="#media-query-bubbling-and-nested-media-queries">media query bubbling</a>, for instance</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@<span class="hljs-keyword">media</span> (orientation:<span class="hljs-preprocessor"> portrait</span>)<span class="hljs-preprocessor"> and</span><span class="hljs-preprocessor"> tv</span> {</span>
  <span class="hljs-class">.my-selector</span> {
    <span class="hljs-attribute">background-color</span><span class="hljs-value">: black;</span>
  }
}
</code></pre>
<p>which will output</p>
<pre><code class="lang-css">@my-ruleset: {
    .my-selector {
      @media tv {
        background-color: black;
      }
    }
  };
@media (orientation:portrait) {
    @my-ruleset();
}
</code></pre>


      <br>
    </div>
    

  </div>

  <!-- Import Directives -->
  <div class="docs-section">
    <div class="page-header">
      <h1 class="docs-heading">Import Directives<span class="anchor-target" id="import-directives-feature"></span>
<a href="#import-directives-feature" name="import-directives-feature" class="anchor glyphicon glyphicon-link"></a></h1>
    </div>

    
    <div class="section-content">
      
<a class="glyphicon glyphicon-pencil source-link right" href="/blob//content_zh/features/import-directives.md" data-content="import-directivesmd" target="_blank"></a>



<a id="import-directivesmd" href="/blob//content_zh/features/import-directives.md" target="_blank">Edit the markdown source for "import-directives"
  <span class="glyphicon glyphicon-new-window"></span>
</a>

      <!-- import-directives -->
       


<blockquote>
<p>从其他样式表中导入样式。</p>
</blockquote>
<p>在标准的CSS中，<code>@import</code>必须在所有其他类型的规则之前。但是Less.js不在乎你把<code>@import</code>语句放在什么位置。</p>
<p>示例：</p>
<pre><code class="lang-less"><span class="hljs-class">.foo</span> {
  <span class="hljs-attribute">background</span><span class="hljs-value">: <span class="hljs-hexcolor">#900</span>;</span>
}
<span class="hljs-at_rule">@<span class="hljs-keyword">import</span> <span class="hljs-string">"this-is-valid.less"</span>;</span>
</code></pre>
<h2 class="docs-heading">文件扩展名<span class="anchor-target" id="import-directives-feature--"></span>
<a href="#import-directives-feature--" name="import-directives-feature--" class="anchor glyphicon glyphicon-link"></a></h2>
<p><code>@import</code>语句会通过Less依赖文件扩展名的方式区别对待不同的文件：</p>
<ul>
<li>如果文件有一个<code>.css</code>扩展名，则将它作为CSS对象，同时<code>@import</code>语句保持不变（查看下面的inline选项）</li>
<li>如果有<em>其他扩展名</em>，则作为Less对象，然后导入它。</li>
<li>如果没有扩展名，则插入<code>.less</code>，然后将它作为Less文件导入包含进来。</li>
</ul>
<p>示例：</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@<span class="hljs-keyword">import</span> <span class="hljs-string">"foo"</span>;</span>      <span class="hljs-comment">// foo.less is imported</span>
<span class="hljs-at_rule">@<span class="hljs-keyword">import</span> <span class="hljs-string">"foo.less"</span>;</span> <span class="hljs-comment">// foo.less is imported</span>
<span class="hljs-at_rule">@<span class="hljs-keyword">import</span> <span class="hljs-string">"foo.php"</span>;</span>  <span class="hljs-comment">// foo.php imported as a less file</span>
<span class="hljs-at_rule">@<span class="hljs-keyword">import</span> <span class="hljs-string">"foo.css"</span>;</span>  <span class="hljs-comment">// statement left in place, as-is</span>
</code></pre>
<p>下面的选项可以用来重写这一行为。</p>
<h1 class="docs-heading">导入选项<span class="anchor-target" id="-"></span>
<a href="#-" name="-" class="anchor glyphicon glyphicon-link"></a></h1>
<blockquote>
<p>Less提供了一系列的CSS扩展来让你使用<code>@import</code>更灵活的导入第三方CSS文件。</p>
</blockquote>
<p>语法：<code>@import (keyword) &quot;filename&quot;;</code></p>
<p>下面导入指令已经被实现了：</p>
<ul>
<li><code>reference</code>：使用Less文件但不输出</li>
<li><code>inline</code>：在输出中包含源文件但不加工它</li>
<li><code>less</code>：将文件作为Less文件对象，无论是什么文件扩展名</li>
<li><code>css</code>：将文件作为CSS文件对象，无论是什么文件扩展名</li>
<li><code>once</code>：只包含文件一次（默认行为）</li>
<li><code>multiple</code>：包含文件多次</li>
</ul>
<h2 class="docs-heading">reference<span class="anchor-target" id="--reference"></span>
<a href="#--reference" name="--reference" class="anchor glyphicon glyphicon-link"></a></h2>
<blockquote>
<p>使用<code>@import (reference)</code>导入外部文件，但是不添加导入的样式到编译输出中，只引用。</p>
</blockquote>
<p>发布于 <a href="https://github.com/less/less.js/blob/masterCHANGELOG.md">v1.5.0</a></p>
<p>示例： <code>@import (reference) &quot;foo.less&quot;;</code></p>
<p><code>reference</code> 是Less语言中最强大的特性之一。想象以下，<code>reference</code>会使用一个<em>引用标记</em>在导入的文件中标记每个指令和选择器，正常导入它，但是生成CSS的时候，&quot;引用的&quot;选择器不会输出（和media query一样只包含选择器引用）。<code>reference</code>样式不会显示在生成的CSS中，除了应用作为mixin或者extend的样式。</p>
<p>此外，<strong><code>reference</code></strong>还依赖于使用的方法（mixin或者extend）生成不同的结果：</p>
<ul>
<li><strong>extend</strong>：当一个选择是extended时，之后新的选择器会标记为<em>非引用</em>，然后将它插入引用<code>@import</code>语句的位置。</li>
<li><strong>mixins</strong>：当<code>reference</code>样式用作显示的mixin时，混合它的规则，标记为<em>非引用</em>，然后正常出现在引用它的地方。</li>
</ul>
<h3 class="docs-heading">reference示例<span class="anchor-target" id="--reference-"></span>
<a href="#--reference-" name="--reference-" class="anchor glyphicon glyphicon-link"></a></h3>
<p>这允许你通过做一些像下面这样的工作从诸如<a href="https://github.com/twbs/bootstrap">Bootstrap</a>的库中拉入特定的，目标样式：</p>
<pre><code class="lang-less"><span class="hljs-class">.navbar</span><span class="hljs-value">:extend(.navbar all) {}</span>
</code></pre>
<p>这样就只会从Bootstrap中拉入<code>.navbar</code>相关的样式。</p>
<h2 class="docs-heading">inline<span class="anchor-target" id="--inline"></span>
<a href="#--inline" name="--inline" class="anchor glyphicon glyphicon-link"></a></h2>
<blockquote>
<p>使用<code>@import (inline)</code>引入外部文件，但不加工他们。</p>
</blockquote>
<p>发布于 <a href="https://github.com/less/less.js/blob/masterCHANGELOG.md">v1.5.0</a></p>
<p>示例: <code>@import (inline) &quot;not-less-compatible.css&quot;;</code></p>
<p>当一个CSS文件可能不兼容Less的时候可以使用这一技术，这是因为尽管Less支持大多数熟知的标准的CSS，但是在有些地方它还是不支持注释，在不修改CSS的情况下它也不支持所有已知的CSS hacks。</p>
<p>因此你可以使用它来在输出中引入文件，最终CSS文件都会在一个地方。</p>
<h2 class="docs-heading">less<span class="anchor-target" id="--less"></span>
<a href="#--less" name="--less" class="anchor glyphicon glyphicon-link"></a></h2>
<blockquote>
<p>使用<code>@import (less)</code>会将导入的文件作为Less文件对象，不管文件扩展名是什么。</p>
<p>发布于 <a href="https://github.com/less/less.js/blob/masterCHANGELOG.md">v1.4.0</a></p>
</blockquote>
<p>示例：</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@<span class="hljs-keyword">import</span> (less) <span class="hljs-string">"foo.css"</span>;</span>
</code></pre>
<h2 class="docs-heading">css<span class="anchor-target" id="--css"></span>
<a href="#--css" name="--css" class="anchor glyphicon glyphicon-link"></a></h2>
<blockquote>
<p>使用<code>@import (css)</code>会将带入的文件作为普通的CSS文件对象，也不会管扩展名是什么。这意味着import语句把持不变。</p>
</blockquote>
<p>发布于 <a href="https://github.com/less/less.js/blob/masterCHANGELOG.md">v1.4.0</a></p>
<p>示例：</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@<span class="hljs-keyword">import</span> (css) <span class="hljs-string">"foo.less"</span>;</span>
</code></pre>
<p>输出：</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@<span class="hljs-keyword">import</span> <span class="hljs-string">"foo.less"</span>;</span>
</code></pre>
<h2 class="docs-heading">once<span class="anchor-target" id="--once"></span>
<a href="#--once" name="--once" class="anchor glyphicon glyphicon-link"></a></h2>
<blockquote>
<p><code>@import</code>语句的默认行为。这意味着文件只会被导入一次，而随后的导入文件的语句都会被忽略。</p>
</blockquote>
<p>发布于 <a href="https://github.com/less/less.js/blob/masterCHANGELOG.md">v1.4.0</a></p>
<p>这个<code>@import</code>语句的默认行为。</p>
<p>示例：</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@<span class="hljs-keyword">import</span> (once) <span class="hljs-string">"foo.less"</span>;</span>
<span class="hljs-at_rule">@<span class="hljs-keyword">import</span> (once) <span class="hljs-string">"foo.less"</span>;</span> <span class="hljs-comment">// this statement will be ignored</span>
</code></pre>
<h2 class="docs-heading">multiple<span class="anchor-target" id="--multiple"></span>
<a href="#--multiple" name="--multiple" class="anchor glyphicon glyphicon-link"></a></h2>
<blockquote>
<p>使用<code>@import (multiple)</code>允许导入多个同名文件。这与只能导入一次的行为是对立的。</p>
</blockquote>
<p>发布于 <a href="https://github.com/less/less.js/blob/masterCHANGELOG.md">v1.4.0</a></p>
<p>示例：</p>
<pre><code class="lang-less"><span class="hljs-comment">// file: foo.less</span>
<span class="hljs-class">.a</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: green;</span>
}
<span class="hljs-comment">// file: main.less</span>
<span class="hljs-at_rule">@<span class="hljs-keyword">import</span> (multiple) <span class="hljs-string">"foo.less"</span>;</span>
<span class="hljs-at_rule">@<span class="hljs-keyword">import</span> (multiple) <span class="hljs-string">"foo.less"</span>;</span>
</code></pre>
<p>输出：</p>
<pre><code class="lang-less"><span class="hljs-class">.a</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: green;</span>
}
<span class="hljs-class">.a</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: green;</span>
}
</code></pre>


      <br>
    </div>
    

  </div>

  <!-- Mixin Guards -->
  <div class="docs-section">
    <div class="page-header">
      <h1 class="docs-heading">Mixin Guards<span class="anchor-target" id="mixin-guards-feature"></span>
<a href="#mixin-guards-feature" name="mixin-guards-feature" class="anchor glyphicon glyphicon-link"></a></h1>
    </div>

    
    <div class="section-content">
      
<a class="glyphicon glyphicon-pencil source-link right" href="/blob//content_zh/features/mixin-guards.md" data-content="mixin-guardsmd" target="_blank"></a>



<a id="mixin-guardsmd" href="/blob//content_zh/features/mixin-guards.md" target="_blank">Edit the markdown source for "mixin-guards"
  <span class="glyphicon glyphicon-new-window"></span>
</a>

      <!-- mixin-guards -->
       


<blockquote>
<p>带条件的mixins。</p>
</blockquote>
<p>当你想要匹配<em>表达式</em>，而不是简单的值或者参数数量时，guard是很有用的。如果你熟悉函数式编程，那么你肯定遇到过这类问题。</p>
<p>为了尽可能的保持CSS声明的本质，Less选择实现了<strong>guarded mixins</strong>，而不是<code>if</code>/<code>else</code>语句，也就是说并不是一脉相承的实现<code>@media</code>查询的规范。</p>
<p>让我们从一个例子开始：</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span> (<span class="hljs-at_rule">@a)<span class="hljs-preprocessor"> when</span> (<span class="hljs-function">lightness(@a)</span> &gt;=<span class="hljs-preprocessor"> 50</span>%) {</span>
  <span class="hljs-attribute">background-color</span><span class="hljs-value">: black;</span>
}
<span class="hljs-class">.mixin</span> (<span class="hljs-at_rule">@a)<span class="hljs-preprocessor"> when</span> (<span class="hljs-function">lightness(@a)</span> &lt;<span class="hljs-preprocessor"> 50</span>%) {</span>
  <span class="hljs-attribute">background-color</span><span class="hljs-value">: white;</span>
}
<span class="hljs-class">.mixin</span> (<span class="hljs-at_rule">@a) {</span>
  <span class="hljs-attribute">color</span><span class="hljs-value">: @a;</span>
}
</code></pre>
<p>这里有一个<code>when</code>关键字，它引进了一个guard序列（在这里只有一个guard）。现在，假设我们运行以下代码：</p>
<pre><code class="lang-less"><span class="hljs-class">.class1</span> { <span class="hljs-class">.mixin</span>(<span class="hljs-id">#ddd</span>) }
<span class="hljs-class">.class2</span> { <span class="hljs-class">.mixin</span>(<span class="hljs-id">#555</span>) }
</code></pre>
<p>会得到：</p>
<pre><code class="lang-css"><span class="hljs-class">.class1</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">background-color</span>:<span class="hljs-value"> black</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#ddd</span></span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-class">.class2</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">background-color</span>:<span class="hljs-value"> white</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#555</span></span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<h3 class="docs-heading">Guard中的比较运算符<span class="anchor-target" id="mixin-guards-feature-guard-"></span>
<a href="#mixin-guards-feature-guard-" name="mixin-guards-feature-guard-" class="anchor glyphicon glyphicon-link"></a></h3>
<p>guards中可用的比较运算符的完整列表为： <code>&gt;</code>, <code>&gt;=</code>, <code>=</code>, <code>=&lt;</code>, <code>&lt;</code>。此外，关键字<code>true</code>是让两个mixins等价的唯一真值：</p>
<pre><code class="lang-less"><span class="hljs-class">.truth</span> (<span class="hljs-at_rule">@a)<span class="hljs-preprocessor"> when</span> (@a) {</span> ... }
<span class="hljs-class">.truth</span> (<span class="hljs-at_rule">@a)<span class="hljs-preprocessor"> when</span> (@a =<span class="hljs-preprocessor"> true</span>) {</span> ... }
</code></pre>
<p>除了关键字<code>true</code>，其他任何值都是假值：</p>
<pre><code class="lang-less"><span class="hljs-class">.class</span> {
  <span class="hljs-class">.truth</span>(40); <span class="hljs-comment">// Will not match any of the above definitions.</span>
}
</code></pre>
<p>Guards可以使用逗号<code>,</code>分割，如果guards求值都为<code>true</code>，它就被认为是一个相等的匹配：</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span> (<span class="hljs-at_rule">@a)<span class="hljs-preprocessor"> when</span> (@a &gt;<span class="hljs-preprocessor"> 10</span>), (@a &lt;<span class="hljs-preprocessor"> -10</span>) {</span> ... }
</code></pre>
<p>注意，你也可以比较其他每个参数或者不使用参数：</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@<span class="hljs-keyword">media</span>:<span class="hljs-preprocessor"> mobile</span>;</span>

<span class="hljs-class">.mixin</span> (<span class="hljs-at_rule">@a)<span class="hljs-preprocessor"> when</span> (@<span class="hljs-keyword">media</span> =<span class="hljs-preprocessor"> mobile</span>) {</span> ... }
<span class="hljs-class">.mixin</span> (<span class="hljs-at_rule">@a)<span class="hljs-preprocessor"> when</span> (@<span class="hljs-keyword">media</span> =<span class="hljs-preprocessor"> desktop</span>) {</span> ... }

<span class="hljs-class">.max</span> (<span class="hljs-at_rule">@a;</span> <span class="hljs-at_rule">@b)<span class="hljs-preprocessor"> when</span> (@a &gt; @b) {</span> <span class="hljs-attribute">width</span><span class="hljs-value">: @a }
.max (@a;</span> <span class="hljs-at_rule">@b)<span class="hljs-preprocessor"> when</span> (@a &lt; @b) {</span> <span class="hljs-attribute">width</span><span class="hljs-value">: @b }</span>
</code></pre>
<h3 class="docs-heading">Guard logical operators<span class="anchor-target" id="mixin-guards-feature-guard-logical-operators"></span>
<a href="#mixin-guards-feature-guard-logical-operators" name="mixin-guards-feature-guard-logical-operators" class="anchor glyphicon glyphicon-link"></a></h3>
<p>You can use logical operators with guards. The syntax is based on CSS media queries.</p>
<p>Use the <code>and</code> keyword to combine guards:</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span> (<span class="hljs-at_rule">@a)<span class="hljs-preprocessor"> when</span> (<span class="hljs-function">isnumber(@a)</span>)<span class="hljs-preprocessor"> and</span> (@a &gt;<span class="hljs-preprocessor"> 0</span>) {</span> ... }
</code></pre>
<p>You can emulate the <em>or</em> operator by separating guards with a comma <code>,</code>. If any of the guards evaluate to true, it&#39;s considered a match:</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span> (<span class="hljs-at_rule">@a)<span class="hljs-preprocessor"> when</span> (@a &gt;<span class="hljs-preprocessor"> 10</span>), (@a &lt;<span class="hljs-preprocessor"> -10</span>) {</span> ... }
</code></pre>
<p>Use the <code>not</code> keyword to negate conditions:</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span> (<span class="hljs-at_rule">@b)<span class="hljs-preprocessor"> when</span><span class="hljs-preprocessor"> not</span> (@b &gt;<span class="hljs-preprocessor"> 0</span>) {</span> ... }
</code></pre>
<h3 class="docs-heading">类型检查函数<span class="anchor-target" id="mixin-guards-feature--"></span>
<a href="#mixin-guards-feature--" name="mixin-guards-feature--" class="anchor glyphicon glyphicon-link"></a></h3>
<p>最后，如果你想基于值类型匹配mixins，那么你可以使用<code>is</code>函数：</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span> (<span class="hljs-at_rule">@a;</span> <span class="hljs-at_rule">@b:<span class="hljs-preprocessor"> 0</span>)<span class="hljs-preprocessor"> when</span> (<span class="hljs-function">isnumber(@b)</span>) {</span> ... }
<span class="hljs-class">.mixin</span> (<span class="hljs-at_rule">@a;</span> <span class="hljs-at_rule">@b:<span class="hljs-preprocessor"> black</span>)<span class="hljs-preprocessor"> when</span> (<span class="hljs-function">iscolor(@b)</span>) {</span> ... }
</code></pre>
<p>下面是一些基本的类型检查函数：</p>
<ul>
<li><code>iscolor</code></li>
<li><code>isnumber</code></li>
<li><code>isstring</code></li>
<li><code>iskeyword</code></li>
<li><code>isurl</code></li>
</ul>
<p>如果你想检查一个值除了数字是否是一个特定的单位，你可以使用下列方法之一：</p>
<ul>
<li><code>ispixel</code></li>
<li><code>ispercentage</code></li>
<li><code>isem</code></li>
<li><code>isunit</code></li>
</ul>
<h3 class="docs-heading">带条件的mixins<span class="anchor-target" id="mixin-guards-feature--mixins"></span>
<a href="#mixin-guards-feature--mixins" name="mixin-guards-feature--mixins" class="anchor glyphicon glyphicon-link"></a></h3>
<p><em>(<strong>FIXME</strong>)</em> 此外，<code>default</code>函数可以用于让一个mixin匹配依赖于其他mixin匹配，然后你可以使用它来创建类似于<code>else</code>或者<code>default</code>语句（分别属于<code>if</code>和<code>case</code>结构）的“条件式mixins”：</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span> (<span class="hljs-at_rule">@a)<span class="hljs-preprocessor"> when</span> (@a &gt;<span class="hljs-preprocessor"> 0</span>) {</span> ...  }
<span class="hljs-class">.mixin</span> (<span class="hljs-at_rule">@a)<span class="hljs-preprocessor"> when</span> (<span class="hljs-function">default()</span>) {</span> ... } <span class="hljs-comment">// matches only if first mixin does not, i.e. when @a &lt;= 0</span>
</code></pre>


      <br>
    </div>
    

  </div>

  <!-- CSS Guards -->
  <div class="docs-section">
    <div class="page-header">
      <h1 class="docs-heading">CSS Guards<span class="anchor-target" id="css-guards-feature"></span>
<a href="#css-guards-feature" name="css-guards-feature" class="anchor glyphicon glyphicon-link"></a></h1>
    </div>

    
    <div class="section-content">
      
<a class="glyphicon glyphicon-pencil source-link right" href="/blob//content_zh/features/css-guards.md" data-content="css-guardsmd" target="_blank"></a>



<a id="css-guardsmd" href="/blob//content_zh/features/css-guards.md" target="_blank">Edit the markdown source for "css-guards"
  <span class="glyphicon glyphicon-new-window"></span>
</a>

      <!-- css-guards -->
       


<blockquote>
<p>类似&quot;if&quot;形式的选择器</p>
</blockquote>
<p>发布于 <a href="https://github.com/less/less.js/blob/masterCHANGELOG.md">v1.5.0</a></p>
<p>约束也适用于CSS选择器，这是一个声明mixin的语法糖，会立即调用它。</p>
<p>例如，在1.5.0之前你不得不这样做。</p>
<pre><code class="lang-less"><span class="hljs-class">.my-optional-style</span>() when (<span class="hljs-at_rule">@my-option =<span class="hljs-preprocessor"> true</span>) {</span>
  <span class="hljs-tag">button</span> {
    <span class="hljs-attribute">color</span><span class="hljs-value">: white;</span>
  }
}
<span class="hljs-class">.my-optional-style</span>();
</code></pre>
<p>现在你可以直接在样式上编写约束。</p>
<pre><code class="lang-less"><span class="hljs-tag">button</span> when (<span class="hljs-at_rule">@my-option =<span class="hljs-preprocessor"> true</span>) {</span>
  <span class="hljs-attribute">color</span><span class="hljs-value">: white;</span>
}
</code></pre>
<p>你还可以通过与<code>&amp;</code>特性结合实现&#39;if&#39;类型的语句，从而允许组合多个约束。</p>
<pre><code class="lang-less">&amp; when (<span class="hljs-at_rule">@my-option =<span class="hljs-preprocessor"> true</span>) {</span>
  <span class="hljs-tag">button</span> {
    <span class="hljs-attribute">color</span><span class="hljs-value">: white;</span>
  }
  <span class="hljs-tag">a</span> {
    <span class="hljs-attribute">color</span><span class="hljs-value">: blue;</span>
  }
}
</code></pre>


      <br>
    </div>
    

  </div>

  <!-- Loops -->
  <div class="docs-section">
    <div class="page-header">
      <h1 class="docs-heading">Loops<span class="anchor-target" id="loops-feature"></span>
<a href="#loops-feature" name="loops-feature" class="anchor glyphicon glyphicon-link"></a></h1>
    </div>

    
    <div class="section-content">
      
<a class="glyphicon glyphicon-pencil source-link right" href="/blob//content_zh/features/loops.md" data-content="loopsmd" target="_blank"></a>



<a id="loopsmd" href="/blob//content_zh/features/loops.md" target="_blank">Edit the markdown source for "loops"
  <span class="glyphicon glyphicon-new-window"></span>
</a>

      <!-- loops -->
       


<blockquote>
<p>编写循环</p>
</blockquote>
<p>在Less中，混合可以调用它自身。这样，当一个混合递归调用自己，再结合<a href="#mixin-guards-feature">Guard表达式</a>和<a href="#mixins-parametric-feature-pattern-matching">模式匹配</a>这两个特性，就可以写出循环结构。</p>
<p>示例：</p>
<pre><code class="lang-less"><span class="hljs-class">.loop</span>(<span class="hljs-at_rule">@counter)<span class="hljs-preprocessor"> when</span> (@counter &gt;<span class="hljs-preprocessor"> 0</span>) {</span>
  <span class="hljs-class">.loop</span>((<span class="hljs-at_rule">@counter<span class="hljs-preprocessor"> -</span><span class="hljs-preprocessor"> 1</span>));</span>    <span class="hljs-comment">// 递归调用自身</span>
  <span class="hljs-attribute">width</span><span class="hljs-value">: (<span class="hljs-number">10</span>px * @counter);</span> <span class="hljs-comment">// 每次调用时产生的样式代码</span>
}

<span class="hljs-tag">div</span> {
  <span class="hljs-class">.loop</span>(5); <span class="hljs-comment">// 调用循环</span>
}
</code></pre>
<p>输出：</p>
<pre><code class="lang-css"><span class="hljs-tag">div</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">10</span>px</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">20</span>px</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">30</span>px</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">40</span>px</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">50</span>px</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>使用递归循环最常见的情况就是生成栅格系统的CSS：</p>
<pre><code class="lang-less"><span class="hljs-class">.generate-columns</span>(4);

<span class="hljs-class">.generate-columns</span>(<span class="hljs-at_rule">@n, @i:<span class="hljs-preprocessor"> 1</span>)<span class="hljs-preprocessor"> when</span> (@i =&lt; @n) {</span>
  <span class="hljs-class">.column-</span><span class="hljs-at_rule">@{</span><span class="hljs-tag">i</span>} {
    <span class="hljs-attribute">width</span><span class="hljs-value">: (@i * <span class="hljs-number">100</span>% / @n);</span>
  }
  <span class="hljs-class">.generate-columns</span>(<span class="hljs-at_rule">@n, (@i +<span class="hljs-preprocessor"> 1</span>));</span>
}
</code></pre>
<p>输出：</p>
<pre><code class="lang-css"><span class="hljs-class">.column-1</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">25</span>%</span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-class">.column-2</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">50</span>%</span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-class">.column-3</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">75</span>%</span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-class">.column-4</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">100</span>%</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>


      <br>
    </div>
    

  </div>

  <!-- Merge -->
  <div class="docs-section">
    <div class="page-header">
      <h1 class="docs-heading">Merge<span class="anchor-target" id="merge-feature"></span>
<a href="#merge-feature" name="merge-feature" class="anchor glyphicon glyphicon-link"></a></h1>
    </div>

    
    <div class="section-content">
      
<a class="glyphicon glyphicon-pencil source-link right" href="/blob//content_zh/features/merge.md" data-content="mergemd" target="_blank"></a>



<a id="mergemd" href="/blob//content_zh/features/merge.md" target="_blank">Edit the markdown source for "merge"
  <span class="glyphicon glyphicon-new-window"></span>
</a>

      <!-- merge -->
       


<blockquote>
<p>合并属性</p>
</blockquote>
<p><code>merge</code>特性可以从多个属性中将值集合集合到一个单一属性之下的逗号或空格分割属性列表中。对于诸如background和transform之类的属性来说，<code>merge</code>非常有用。</p>
<h2 class="docs-heading">逗号<span class="anchor-target" id="merge-feature--"></span>
<a href="#merge-feature--" name="merge-feature--" class="anchor glyphicon glyphicon-link"></a></h2>
<blockquote>
<p>通过逗号添加属性的值</p>
</blockquote>
<p>发布于 <a href="https://github.com/less/less.js/blob/masterCHANGELOG.md">v1.5.0</a></p>
<p>示例：</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span>() {
  <span class="hljs-attribute">box-shadow</span>+<span class="hljs-value">: inset <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10</span>px <span class="hljs-hexcolor">#555</span>;</span>
}
<span class="hljs-class">.myclass</span> {
  <span class="hljs-class">.mixin</span>();
  <span class="hljs-attribute">box-shadow</span>+<span class="hljs-value">: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">20</span>px black;</span>
}
</code></pre>
<p>输出：</p>
<pre><code class="lang-css"><span class="hljs-class">.myclass</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">box-shadow</span>:<span class="hljs-value"> inset <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10</span>px <span class="hljs-hexcolor">#555</span>, <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">20</span>px black</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<h2 class="docs-heading">Space<span class="anchor-target" id="merge-feature-space"></span>
<a href="#merge-feature-space" name="merge-feature-space" class="anchor glyphicon glyphicon-link"></a></h2>
<blockquote>
<p>Append property value with space</p>
</blockquote>
<p>Released <a href="https://github.com/less/less.js/blob/masterCHANGELOG.md">v1.7.0</a></p>
<p>Example:</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span>() {
  <span class="hljs-attribute">transform</span>+_<span class="hljs-value">: scale(<span class="hljs-number">2</span>);</span>
}
<span class="hljs-class">.myclass</span> {
  <span class="hljs-class">.mixin</span>();
  <span class="hljs-attribute">transform</span>+_<span class="hljs-value">: rotate(<span class="hljs-number">15</span>deg);</span>
}
</code></pre>
<p>Outputs</p>
<pre><code class="lang-css"><span class="hljs-class">.myclass</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">transform</span>:<span class="hljs-value"> <span class="hljs-function">scale(<span class="hljs-number">2</span>)</span> <span class="hljs-function">rotate(<span class="hljs-number">15</span>deg)</span></span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>为避免任何非有意的添加，<code>merge</code>需要在每个待加入的声明中显示的设置一个<code>+</code>或者<code>+_</code>标记。</p>
<p><em>注意：尽管transform规范中属性使用空格分割，但它仍然支持使用逗号分割；这也是为什么这个特性中没有选项来配置用空格还是逗号分割的原因。</em></p>


      <br>
    </div>
    

  </div>

  <!-- Parent Selectors -->
  <div class="docs-section">
    <div class="page-header">
      <h1 class="docs-heading">Parent Selectors<span class="anchor-target" id="parent-selectors-feature"></span>
<a href="#parent-selectors-feature" name="parent-selectors-feature" class="anchor glyphicon glyphicon-link"></a></h1>
    </div>

    
    <div class="section-content">
      
<a class="glyphicon glyphicon-pencil source-link right" href="/blob//content_zh/features/parent-selectors.md" data-content="parent-selectorsmd" target="_blank"></a>



<a id="parent-selectorsmd" href="/blob//content_zh/features/parent-selectors.md" target="_blank">Edit the markdown source for "parent-selectors"
  <span class="glyphicon glyphicon-new-window"></span>
</a>

      <!-- parent-selectors -->
       


<blockquote>
<p>使用<code>&amp;</code>引用父选择器</p>
</blockquote>
<p><code>&amp;</code>运算符表示一个嵌套规则的父选择器，它在应用修改类或者应用伪类给现有选择器时最常用：</p>
<pre><code class="lang-less"><span class="hljs-tag">a</span> {
  <span class="hljs-attribute">color</span><span class="hljs-value">: blue;</span>
  &amp;<span class="hljs-pseudo">:hover</span> {
    <span class="hljs-attribute">color</span><span class="hljs-value">: green;</span>
  }
}
</code></pre>
<p>结果为：</p>
<pre><code class="lang-css"><span class="hljs-tag">a</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> blue</span></span>;
<span class="hljs-rule">}</span></span>

<span class="hljs-tag">a</span><span class="hljs-pseudo">:hover</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> green</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>注意，如果上面的示例没有使用<code>&amp;</code>，那么它的结果就是<code>a :hover</code>（一个匹配<code>&lt;a&gt;</code>标签内的hovered元素的后代选择器），这通常并不是我么想要的嵌套的<code>:hover</code>的结果。</p>
<p>“父选择器”有各种各样的用法。基本上，任何时候你都需要以不同的方式来组合选择器嵌套的规则，而不是默认规则。比如，一个使用<code>&amp;</code>的典型的场景就是生成重复的类名：</p>
<pre><code class="lang-less"><span class="hljs-class">.button</span> {
  &amp;-ok {
    <span class="hljs-attribute">background-image</span><span class="hljs-value">: url(<span class="hljs-string">"ok.png"</span>);</span>
  }
  &amp;-cancel {
    <span class="hljs-attribute">background-image</span><span class="hljs-value">: url(<span class="hljs-string">"cancel.png"</span>);</span>
  }

  &amp;-custom {
    <span class="hljs-attribute">background-image</span><span class="hljs-value">: url(<span class="hljs-string">"custom.png"</span>);</span>
  }
}
</code></pre>
<p>输出：</p>
<pre><code class="lang-css"><span class="hljs-class">.button-ok</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">background-image</span>:<span class="hljs-value"> <span class="hljs-function">url(<span class="hljs-string">"ok.png"</span>)</span></span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-class">.button-cancel</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">background-image</span>:<span class="hljs-value"> <span class="hljs-function">url(<span class="hljs-string">"cancel.png"</span>)</span></span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-class">.button-custom</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">background-image</span>:<span class="hljs-value"> <span class="hljs-function">url(<span class="hljs-string">"custom.png"</span>)</span></span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<h3 class="docs-heading">多个 <code>&amp;</code><span class="anchor-target" id="parent-selectors-feature--"></span>
<a href="#parent-selectors-feature--" name="parent-selectors-feature--" class="anchor glyphicon glyphicon-link"></a></h3>
<p><code>&amp;</code>可以在一个选择器中出现不止一次。这就使得它可以反复引用父选择器，而不是重复父选择器的类名。</p>
<pre><code class="lang-less"><span class="hljs-class">.link</span> {
  &amp; + &amp; {
    <span class="hljs-attribute">color</span><span class="hljs-value">: red;</span>
  }

  &amp; &amp; {
    <span class="hljs-attribute">color</span><span class="hljs-value">: green;</span>
  }

  &amp;&amp; {
    <span class="hljs-attribute">color</span><span class="hljs-value">: blue;</span>
  }

  &amp;, &amp;ish {
    <span class="hljs-attribute">color</span><span class="hljs-value">: cyan;</span>
  }
}
</code></pre>
<p>这会输出：</p>
<pre><code class="lang-css"><span class="hljs-class">.link</span> + <span class="hljs-class">.link</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> red</span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-class">.link</span> <span class="hljs-class">.link</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> green</span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-class">.link</span><span class="hljs-class">.link</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> blue</span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-class">.link</span>, <span class="hljs-class">.linkish</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> cyan</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>注意，<code>&amp;</code>代表所有的父选择器（而不只是最近的长辈），因此下面的例子：</p>
<pre><code class="lang-less"><span class="hljs-class">.grand</span> {
  <span class="hljs-class">.parent</span> {
    &amp; &gt; &amp; {
      <span class="hljs-attribute">color</span><span class="hljs-value">: red;</span>
    }

    &amp; &amp; {
      <span class="hljs-attribute">color</span><span class="hljs-value">: green;</span>
    }

    &amp;&amp; {
      <span class="hljs-attribute">color</span><span class="hljs-value">: blue;</span>
    }

    &amp;, &amp;ish {
      <span class="hljs-attribute">color</span><span class="hljs-value">: cyan;</span>
    }
  }
}
</code></pre>
<p>结果为：</p>
<pre><code class="lang-css"><span class="hljs-class">.grand</span> <span class="hljs-class">.parent</span> &gt; <span class="hljs-class">.grand</span> <span class="hljs-class">.parent</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> red</span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-class">.grand</span> <span class="hljs-class">.parent</span> <span class="hljs-class">.grand</span> <span class="hljs-class">.parent</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> green</span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-class">.grand</span> <span class="hljs-class">.parent</span><span class="hljs-class">.grand</span> <span class="hljs-class">.parent</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> blue</span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-class">.grand</span> <span class="hljs-class">.parent</span>,
<span class="hljs-class">.grand</span> <span class="hljs-class">.parentish</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> cyan</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<h3 class="docs-heading">改变选择器顺序<span class="anchor-target" id="parent-selectors-feature--"></span>
<a href="#parent-selectors-feature--" name="parent-selectors-feature--" class="anchor glyphicon glyphicon-link"></a></h3>
<p>要前置插入一个选择器给继承的(父)选择器时它是很有用的。用过将<code>&amp;</code>放到当前选择器之后就可以做到这一点。</p>
<p>比如，使用Modernizr时，你可能希望基于要支持的特性来指定不同的规则：</p>
<pre><code class="lang-less"><span class="hljs-class">.header</span> {
  <span class="hljs-class">.menu</span> {
    <span class="hljs-attribute">border-radius</span><span class="hljs-value">: <span class="hljs-number">5</span>px;</span>
    <span class="hljs-class">.no-borderradius</span> &amp; {
      <span class="hljs-attribute">background-image</span><span class="hljs-value">: url(<span class="hljs-string">'images/button-background.png'</span>);</span>
    }
  }
}
</code></pre>
<p>选择器<code>.no-borderradius &amp;</code>会前置插入<code>.no-borderradius</code>给它的父选择器<code>.header .menu</code>，最后变成<code>.no-borderradius .header .menu</code>形式输出：</p>
<pre><code class="lang-css"><span class="hljs-class">.header</span> <span class="hljs-class">.menu</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">border-radius</span>:<span class="hljs-value"> <span class="hljs-number">5</span>px</span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-class">.no-borderradius</span> <span class="hljs-class">.header</span> <span class="hljs-class">.menu</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">background-image</span>:<span class="hljs-value"> <span class="hljs-function">url(<span class="hljs-string">'images/button-background.png'</span>)</span></span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<h3 class="docs-heading">组合使用(explosion-&gt;爆发?)<span class="anchor-target" id="parent-selectors-feature--explosion-"></span>
<a href="#parent-selectors-feature--explosion-" name="parent-selectors-feature--explosion-" class="anchor glyphicon glyphicon-link"></a></h3>
<p><code>&amp;</code>还可以用于生成一个逗号分割列表的所有可能的选择器排列：</p>
<pre><code class="lang-less"><span class="hljs-tag">p</span>, <span class="hljs-tag">a</span>, <span class="hljs-tag">ul</span>, <span class="hljs-tag">li</span> {
<span class="hljs-attribute">border-top</span><span class="hljs-value">: <span class="hljs-number">2</span>px dotted <span class="hljs-hexcolor">#366</span>;</span>
  &amp; + &amp; {
      <span class="hljs-attribute">border-top</span><span class="hljs-value">: <span class="hljs-number">0</span>;</span>
  }
}
</code></pre>
<p>这个组合可以扩展出指定元素的所有（16种）可能的组合：</p>
<pre><code class="lang-css"><span class="hljs-tag">p</span>,
<span class="hljs-tag">a</span>,
<span class="hljs-tag">ul</span>,
<span class="hljs-tag">li</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">border-top</span>:<span class="hljs-value"> <span class="hljs-number">2</span>px dotted <span class="hljs-hexcolor">#366</span></span></span>;
<span class="hljs-rule">}</span></span>
<span class="hljs-tag">p</span> + <span class="hljs-tag">p</span>,
<span class="hljs-tag">p</span> + <span class="hljs-tag">a</span>,
<span class="hljs-tag">p</span> + <span class="hljs-tag">ul</span>,
<span class="hljs-tag">p</span> + <span class="hljs-tag">li</span>,
<span class="hljs-tag">a</span> + <span class="hljs-tag">p</span>,
<span class="hljs-tag">a</span> + <span class="hljs-tag">a</span>,
<span class="hljs-tag">a</span> + <span class="hljs-tag">ul</span>,
<span class="hljs-tag">a</span> + <span class="hljs-tag">li</span>,
<span class="hljs-tag">ul</span> + <span class="hljs-tag">p</span>,
<span class="hljs-tag">ul</span> + <span class="hljs-tag">a</span>,
<span class="hljs-tag">ul</span> + <span class="hljs-tag">ul</span>,
<span class="hljs-tag">ul</span> + <span class="hljs-tag">li</span>,
<span class="hljs-tag">li</span> + <span class="hljs-tag">p</span>,
<span class="hljs-tag">li</span> + <span class="hljs-tag">a</span>,
<span class="hljs-tag">li</span> + <span class="hljs-tag">ul</span>,
<span class="hljs-tag">li</span> + <span class="hljs-tag">li</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">border-top</span>:<span class="hljs-value"> <span class="hljs-number">0</span></span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>


      <br>
    </div>
    

  </div>

</div>
        </div>
      </div>
    </div>

    
    <footer class="footer" role="contentinfo">
  <div class="container">
    <div class="bs-social">
  <ul class="bs-social-buttons">
    <li>
      <iframe class="github-btn" src="http://ghbtns.com/github-btn.html?user=less&amp;repo=less.js&amp;type=watch&amp;count=true" width="100" height="20" title="Star on GitHub"></iframe>
    </li>
    <li>
      <iframe class="github-btn" src="http://ghbtns.com/github-btn.html?user=less&amp;repo=less.js&amp;type=fork&amp;count=true" width="102" height="20" title="Fork on GitHub"></iframe>
    </li>
  </ul>
</div>

    <p>Less.js and these docs are maintained by <a href="../about/#team">the core less team</a>.</p>
    <p>Documentation source code released under the <a href="https://github.com/less/less-docs/blob/master/LICENSE-MIT" target="_blank">MIT License</a>, documentation under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>.</p>
    <ul class="footer-links">
      <li>Currently v1.7.1</li>
      
      <li class="muted">&middot;</li>
      <li><a href="https://github.com/less/less.js/issues">Less.js Issues</a></li>
      <li class="muted">&middot;</li>
      <li><a href="https://github.com/less/less-docs/issues?&amp;state=open">Less Docs Issues</a></li>
      <li class="muted">&middot;</li>
      <li><a href="https://github.com/less/less.js/blob/master/CHANGELOG.md">Changelog</a></li>
      
    </ul>
  </div>
</footer>


    
    <!-- Core JavaScript
================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script src="//code.jquery.com/jquery-1.10.2.min.js"></script>
<script src="//netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script>


<script src="//cdnjs.cloudflare.com/ajax/libs/holder/2.2.0/holder.min.js"></script>
<script src="../public/js/application.js"></script>




  </body>
</html>